{
	"info": {
		"_postman_id": "89c15bc5-87ea-4565-9449-2bb0c87a796b",
		"name": "LMS_Hackathon_Phase1",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "13338982",
		"_collection_link": "https://red-station-1386.postman.co/workspace/Team06_PostmanExplorers_LMS_Pha~81ecc9bd-02bd-4543-a818-05f8ddf606b1/collection/13338982-89c15bc5-87ea-4565-9449-2bb0c87a796b?action=share&source=collection_link&creator=13338982"
	},
	"item": [
		{
			"name": "LoginModule",
			"item": [
				{
					"name": "LoginWithValidCredentials",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"\r",
									"const response=pm.response.json();\r",
									"\r",
									"const access_token = response.token;\r",
									"pm.globals.set('access_token',access_token)\r",
									"\r",
									"//status  code and message  verification\r",
									"pm.test(\"Status code is 200\", ()=> {\r",
									"    pm.response.to.have.status(200);\r",
									"    pm.response.to.have.status(\"OK\");\r",
									"});\r",
									"//header verification\r",
									"pm.test(\"Header validation\",()=> {\r",
									"    pm.response.to.have.header(\"Content-Type\");\r",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');\r",
									"});\r",
									"\r",
									"if (pm.response.code === 200) {\r",
									"pm.test(\"validate response body properties\", () => {\r",
									"    // Check the expected properties exist\r",
									"    pm.expect(pm.response.text()).to.include(\"userId\");\r",
									"    pm.expect(pm.response.text()).to.include(\"email\");\r",
									"    pm.expect(pm.response.text()).to.include(\"status\");\r",
									"    pm.expect(pm.response.text()).to.include(\"token\");\r",
									"    pm.expect(pm.response.text()).to.include(\"type\");\r",
									"    pm.expect(pm.response.text()).to.include(\"roles\");\r",
									"    pm.expect(pm.response.text()).to.include(\"passwordExpired\");\r",
									"    \r",
									"});\r",
									"\r",
									" pm.test(\"validate response body datatypes\", () => {\r",
									"        pm.expect(response).to.be.an(\"object\");\r",
									"        pm.expect(response.token).to.be.a('string');\r",
									"        pm.expect(response.type).to.be.a('string');\r",
									"        pm.expect(response.userId).to.be.a('string');\r",
									"        pm.expect(response.email).to.be.a('string');\r",
									"        pm.expect(response.roles[0]).to.be.a('string');\r",
									"        pm.expect(response.status).to.be.a('string');\r",
									"         pm.expect(response.status).to.be.a('string');\r",
									"  });\r",
									"\r",
									"pm.test(\"VERIFY USER\",function(){\r",
									"   pm.expect(response.email).to.be.eq(\"sdet@gmail.com\")\r",
									"   pm.expect(response.status).to.be.eq(\"Active\")\r",
									"})\r",
									"pm.test(\"ROLE_ADMIN\",() =>{\r",
									"    pm.expect(response.roles[0]).to.be.eq('ROLE_ADMIN')\r",
									"});\r",
									"//schema validation\r",
									"var responseschema ={\r",
									"  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\r",
									"  \"type\": \"object\",\r",
									"  \"properties\": {\r",
									"    \"token\": {\r",
									"      \"type\": \"string\"\r",
									"    },\r",
									"    \"type\": {\r",
									"      \"type\": \"string\",\r",
									"      \"enum\": [\"Bearer\"]\r",
									"    },\r",
									"    \"userId\": {\r",
									"      \"type\": \"string\"\r",
									"    },\r",
									"    \"email\": {\r",
									"      \"type\": \"string\",\r",
									"      \"format\": \"email\"\r",
									"    },\r",
									"    \"roles\": {\r",
									"      \"type\": \"array\",\r",
									"      \"items\": {\r",
									"        \"type\": \"string\"\r",
									"      }\r",
									"    },\r",
									"    \"status\": {\r",
									"      \"type\": \"string\",\r",
									"      \"enum\": [\"Active\", \"Inactive\"] // Adjust as needed based on actual values\r",
									"    },\r",
									"    \"passwordExpired\": {\r",
									"      \"type\": \"boolean\"\r",
									"    },\r",
									"  },\r",
									"  \"required\": [\"token\", \"type\", \"userId\", \"email\", \"roles\", \"status\",\"passwordExpired\"],\r",
									"  \"additionalProperties\": false\r",
									"\r",
									"\r",
									"}\r",
									"\r",
									"pm.test(\"Validate schema\", () => {\r",
									"pm.response.to.have.jsonSchema(responseschema);\r",
									"});\r",
									"\r",
									"\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{credentials}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseurl}}/login",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"login"
							]
						}
					},
					"response": []
				},
				{
					"name": "LoginWithInvalidCredentials",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var expected_errormsg='Bad credentials';\r",
									"var responseBody=pm.response.json();\r",
									"var actual_errormsg=responseBody.message;\r",
									"\r",
									"pm.test(\"Should return 401 for unauthorized request\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(401);\r",
									"    });\r",
									"     pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Unauthorized\");\r",
									"    });\r",
									"\r",
									"    pm.test(\"Resposne body should have error message\",function(){\r",
									"        pm.expect(actual_errormsg).to.eql(expected_errormsg);\r",
									"        pm.expect(responseBody.success).to.eql(false)\r",
									"    });"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{invalidLoginCredentials}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseurl}}/login",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"login"
							]
						}
					},
					"response": []
				},
				{
					"name": "LoginWithInvalidEndpoint",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.text();\r",
									"\r",
									"pm.test(\"Should return 404 for not found\", function () {\r",
									"    pm.expect(pm.response.code).to.eql(404);\r",
									"});\r",
									"\r",
									"pm.test(\"Status code name has string\", function () {\r",
									"    pm.response.to.have.status(\"Not Found\");\r",
									"});\r",
									"\r",
									"pm.test(\"Error message Invalid Endpoint\", function () {\r",
									"    pm.expect(responseBody).to.include(\"Invalid endpoint\");\r",
									"});\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{credentials}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseurl}}/{{invalidLoginEndpoint}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"{{invalidLoginEndpoint}}"
							]
						}
					},
					"response": []
				}
			],
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"packages": {},
						"exec": [
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"packages": {},
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "ProgramModule",
			"item": [
				{
					"name": "Add New Program",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"var endpoint = pm.iterationData.get(\"EndPoint\");\r",
									"var baseUrl = pm.globals.get(\"baseurl\");\r",
									"\r",
									"// URL\r",
									"url = baseUrl + endpoint;\r",
									"pm.environment.set(\"url\", url);\r",
									"\r",
									"console.log(url);\r",
									"\r",
									"// Function to handle \"null\" strings and convert them to actual null\r",
									"function handleNull(value) {\r",
									"    return value === \"null\" ? null : value;\r",
									"}\r",
									"\r",
									"var progDesc = handleNull(pm.iterationData.get(\"programDescription\"));\r",
									"var progName = handleNull(pm.iterationData.get(\"programName\"));\r",
									"var status = handleNull(pm.iterationData.get(\"programStatus\"));\r",
									"\r",
									"var programrequestBody = {\r",
									"  \"programDescription\": progDesc,\r",
									"  \"programName\": progName,\r",
									"  \"programStatus\": status\r",
									"};\r",
									"\r",
									"pm.globals.set(\"programrequestBody\", JSON.stringify(programrequestBody));\r",
									"\r",
									"const auth_type = pm.iterationData.get('requiresAuth');\r",
									"console.log(auth_type);\r",
									"\r",
									"if (!auth_type) {\r",
									"   pm.request.auth = {\r",
									"    type: 'noauth'\r",
									"};\r",
									"}\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"const programResponseValidation = pm.require('@red-station-1386/program_response_validation');\r",
									"\r",
									"var expectedStatusCode = pm.iterationData.get('statuscode');\r",
									"\r",
									"if (pm.response.code == 201) {\r",
									"    var response=pm.response.json();\r",
									"    const programId = response.programId;\r",
									"    const programName = response.programName;\r",
									"\r",
									"    pm.collectionVariables.set('ProgramId',programId);\r",
									"    pm.collectionVariables.set('ProgramName',programName);\r",
									"\r",
									"    programResponseValidation.postPutValidation(response);\r",
									"}\r",
									"\r",
									"programResponseValidation.validateStatusCode(expectedStatusCode);\r",
									"\r",
									"\r",
									"   \r",
									"   \r",
									"   \r",
									""
								],
								"type": "text/javascript",
								"packages": {
									"@red-station-1386/program_response_validation": {
										"id": "01931a2a-09f8-7749-8391-a62613bfc9cd"
									}
								}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{programrequestBody}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{url}}",
							"host": [
								"{{url}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "GET All Programs",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"var endpoint = pm.iterationData.get(\"EndPoint\");\r",
									"var baseUrl = pm.globals.get(\"baseurl\");\r",
									"\r",
									"// URL\r",
									"url = baseUrl + endpoint;\r",
									"pm.environment.set(\"geturl\", url);\r",
									"\r",
									"console.log(\"URL :\"  + url);\r",
									"\r",
									"let auth_type = pm.iterationData.get(\"requiresAuth\");\r",
									"\r",
									"if (!auth_type) {\r",
									"    pm.request.auth = {\r",
									"    type: 'noauth'\r",
									"};\r",
									"}\r",
									"\r",
									"\r",
									"\r",
									"\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"const programResponseValidation = pm.require('@red-station-1386/program_response_validation');\r",
									"\r",
									"var statuscode = pm.iterationData.get('statuscode');\r",
									"programResponseValidation.validateStatusCode(statuscode);\r",
									"\r",
									"if (pm.response.code == 200) {\r",
									"    var response=pm.response.json();\r",
									"    programResponseValidation.getValidation(response);\r",
									"    programResponseValidation.validateResponseTime(1000);\r",
									"    programResponseValidation.validateHeaderContent('Content-Type', 'application/json');\r",
									"}\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {
									"@red-station-1386/program_response_validation": {
										"id": "01931a2a-09f8-7749-8391-a62613bfc9cd"
									}
								}
							}
						}
					],
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{geturl}}",
							"host": [
								"{{geturl}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "GET All Programs With Users",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"var endpoint = pm.iterationData.get(\"EndPoint\");\r",
									"var baseUrl = pm.globals.get(\"baseurl\");\r",
									"var token = pm.globals.get(\"access_token\");\r",
									"\r",
									"// URL\r",
									"url = baseUrl + endpoint;\r",
									"pm.environment.set(\"getwithuserurl\", url);\r",
									"\r",
									"console.log(\"URL :\"  + url);\r",
									"\r",
									"let auth_type = pm.iterationData.get(\"requiresAuth\");\r",
									"\r",
									"if (!auth_type) {\r",
									"   pm.request.auth = {\r",
									"    type: 'noauth'\r",
									"};\r",
									"}\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"const programResponseValidation = pm.require('@red-station-1386/program_response_validation');\r",
									"\r",
									"\r",
									"var statuscode = pm.iterationData.get('statuscode');\r",
									"programResponseValidation.validateStatusCode(statuscode);\r",
									"\r",
									"if (pm.response.code == 200) {\r",
									"    var response=pm.response.json();\r",
									"    programResponseValidation.getValidation(response);\r",
									"    programResponseValidation.validateResponseTime(1000);\r",
									"    programResponseValidation.validateHeaderContent('Content-Type', 'application/json');\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {
									"@red-station-1386/program_response_validation": {
										"id": "01931a2a-09f8-7749-8391-a62613bfc9cd"
									}
								}
							}
						}
					],
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{getwithuserurl}}",
							"host": [
								"{{getwithuserurl}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "GET All Programs With Program Id",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"var progId = pm.collectionVariables.get('ProgramId');\r",
									"\r",
									"var endpoint = pm.iterationData.get(\"EndPoint\");\r",
									"var baseUrl = pm.globals.get(\"baseurl\");\r",
									"var token = pm.globals.get(\"access_token\");\r",
									"\r",
									"// URL\r",
									"url = baseUrl + endpoint + '/' + progId;\r",
									"pm.environment.set(\"getwithpidurl\", url);\r",
									"\r",
									"console.log(\"URL :\"  + url);\r",
									"\r",
									"let auth_type = pm.iterationData.get(\"requiresAuth\");\r",
									"\r",
									"if (!auth_type) {\r",
									"   pm.request.auth = {\r",
									"    type: 'noauth'\r",
									"};\r",
									"}\r",
									"\r",
									"\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"const programResponseValidation = pm.require('@red-station-1386/program_response_validation');\r",
									"\r",
									"var progDesc = pm.iterationData.get(\"programDescription\");\r",
									"var progName = pm.iterationData.get(\"programName\");\r",
									"var status = pm.iterationData.get(\"programStatus\");\r",
									"var statuscode = pm.iterationData.get('statuscode');\r",
									"\r",
									"// Get the response body (assuming it's a single object, not an array)\r",
									"var jsonData = pm.response.json();\r",
									"\r",
									"programResponseValidation.validateStatusCode(statuscode);\r",
									"\r",
									"if (pm.response.code == 200) {\r",
									"// Verify that the values in the response match the iteration data\r",
									"pm.test(\"Program Description should match the iteration data\", function () {\r",
									"    pm.expect(jsonData.programDescription).to.eql(progDesc);\r",
									"});\r",
									"\r",
									"pm.test(\"Program Name should match the iteration data\", function () {\r",
									"    pm.expect(jsonData.programName).to.eql(progName);\r",
									"});\r",
									"\r",
									"pm.test(\"Program Status should match the iteration data\", function () {\r",
									"    pm.expect(jsonData.programStatus).to.eql(status);\r",
									"});\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {
									"@red-station-1386/program_response_validation": {
										"id": "01931a2a-09f8-7749-8391-a62613bfc9cd"
									}
								}
							}
						}
					],
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{getwithpidurl}}",
							"host": [
								"{{getwithpidurl}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "UPDATE Program With Program Id",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"var progId = pm.collectionVariables.get('ProgramId');\r",
									"\r",
									"var endpoint = pm.iterationData.get(\"EndPoint\");\r",
									"var baseUrl = pm.globals.get(\"baseurl\");\r",
									"\r",
									"// URL\r",
									"url = baseUrl + endpoint + '/' + progId;\r",
									"\r",
									"pm.environment.set(\"putwithpidurl\", url);\r",
									"\r",
									"// Function to handle \"null\" strings and convert them to actual null\r",
									"function handleNull(value) {\r",
									"    return value === \"null\" ? null : value;\r",
									"}\r",
									"var progDesc = handleNull(pm.iterationData.get(\"programDescription\"));\r",
									"var progName = handleNull(pm.iterationData.get(\"programName\"));\r",
									"var status = handleNull(pm.iterationData.get(\"programStatus\"));\r",
									"\r",
									"var programrequestBody = {\r",
									"  \"programDescription\": progDesc,\r",
									"  \"programName\": progName,\r",
									"  \"programStatus\": status\r",
									"};\r",
									"\r",
									"pm.globals.set(\"programrequestBody\", JSON.stringify(programrequestBody));\r",
									"\r",
									"let auth_type = pm.iterationData.get(\"requiresAuth\");\r",
									"\r",
									"if (!auth_type) {\r",
									"   pm.request.auth = {\r",
									"    type: 'noauth'\r",
									"};\r",
									"}\r",
									"\r",
									"\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"const programResponseValidation = pm.require('@red-station-1386/program_response_validation');\r",
									"\r",
									"var progDesc = pm.iterationData.get(\"programDescription\");\r",
									"var statuscode = pm.iterationData.get('statuscode');\r",
									"\r",
									"programResponseValidation.validateStatusCode(statuscode);\r",
									"\r",
									"if (pm.response.code == 200) {\r",
									"var jsonData = pm.response.json();\r",
									"// Verify that the values in the response match the iteration data\r",
									"pm.test(\"Program Description should match the iteration data\", function () {\r",
									"    pm.expect(jsonData.programDescription).to.eql(progDesc);\r",
									"});\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {
									"@red-station-1386/program_response_validation": {
										"id": "01931a2a-09f8-7749-8391-a62613bfc9cd"
									}
								}
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{programrequestBody}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{putwithpidurl}}",
							"host": [
								"{{putwithpidurl}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "UPDATE Programs With Program Name",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"var progName = pm.collectionVariables.get('ProgramName');\r",
									"\r",
									"var endpoint = pm.iterationData.get(\"EndPoint\");\r",
									"var baseUrl = pm.globals.get(\"baseurl\");\r",
									"\r",
									"// URL\r",
									"url = baseUrl + endpoint + '/' + progName;\r",
									"\r",
									"pm.environment.set(\"putwithpnameurl\", url);\r",
									"\r",
									"console.log(\"URL :\"  + url);\r",
									"// Function to handle \"null\" strings and convert them to actual null\r",
									"function handleNull(value) {\r",
									"    return value === \"null\" ? null : value;\r",
									"}\r",
									"var progDesc = handleNull(pm.iterationData.get(\"programDescription\"));\r",
									"var progName = handleNull(pm.iterationData.get(\"programName\"));\r",
									"var status = handleNull(pm.iterationData.get(\"programStatus\"));\r",
									"\r",
									"var programrequestBody = {\r",
									"  \"programDescription\": progDesc,\r",
									"  \"programName\": progName,\r",
									"  \"programStatus\": status\r",
									"};\r",
									"\r",
									"pm.globals.set(\"programrequestBody\", JSON.stringify(programrequestBody));\r",
									"\r",
									"let auth_type = pm.iterationData.get(\"requiresAuth\");\r",
									"\r",
									"if (!auth_type) {\r",
									"    pm.request.auth = {\r",
									"        type: \"noauth\"\r",
									"    };\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"const programResponseValidation = pm.require('@red-station-1386/program_response_validation');\r",
									"\r",
									"var progDesc = pm.iterationData.get(\"programDescription\");\r",
									"var statuscode = pm.iterationData.get('statuscode');\r",
									"\r",
									"programResponseValidation.validateStatusCode(statuscode);\r",
									"\r",
									"if (pm.response.code == 200) {\r",
									"var jsonData = pm.response.json();\r",
									"// Verify that the values in the response match the iteration data\r",
									"pm.test(\"Program Description should match the iteration data\", function () {\r",
									"    pm.expect(jsonData.programDescription).to.eql(progDesc);\r",
									"});\r",
									"}\r",
									"\r",
									"let auth_type = pm.iterationData.get(\"requiresAuth\");\r",
									"\r",
									"if (!auth_type) {\r",
									"   pm.request.auth = {\r",
									"    type: 'noauth'\r",
									"};\r",
									"}\r",
									""
								],
								"type": "text/javascript",
								"packages": {
									"@red-station-1386/program_response_validation": {
										"id": "01931a2a-09f8-7749-8391-a62613bfc9cd"
									}
								}
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{programrequestBody}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{putwithpnameurl}}",
							"host": [
								"{{putwithpnameurl}}"
							]
						}
					},
					"response": []
				}
			],
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"packages": {},
						"exec": [
							"// Retrieve the operation type for the current iteration\r",
							"const operationType = pm.iterationData.get('Operation').trim(); // Trim to remove spaces\r",
							"const currentRequestName = pm.info.requestName.trim(); // Trim to remove spaces\r",
							"\r",
							"// Flag to determine if the request should be executed\r",
							"let executeRequest = false;\r",
							"\r",
							"// Check and set the flag based on the operation type\r",
							"switch (operationType.toLowerCase()) {\r",
							"    case 'post':\r",
							"        if (currentRequestName.toLowerCase() == 'add new program') {\r",
							"            executeRequest = true;\r",
							"        }\r",
							"        break;\r",
							"    case 'getallprograms':\r",
							"        if (currentRequestName.toLowerCase() == 'get all programs') {\r",
							"            executeRequest = true;\r",
							"        }\r",
							"        break;\r",
							"    case 'getallprogramswithusers':\r",
							"        if (currentRequestName.toLowerCase() == 'get all programs with users') {\r",
							"            executeRequest = true;\r",
							"        }\r",
							"        break;\r",
							"    case 'getallprogramswithprogramid':\r",
							"        if (currentRequestName.toLowerCase() == 'get all programs with program id') {\r",
							"            executeRequest = true;\r",
							"        }\r",
							"        break;\r",
							"    case 'getallprogramswithprogramname':\r",
							"        if (currentRequestName.toLowerCase() == 'get all programs with program name') {\r",
							"            executeRequest = true;\r",
							"        }\r",
							"        break;\r",
							"    case 'putwithpid':\r",
							"        if (currentRequestName.toLowerCase() == 'update program with program id') {\r",
							"            executeRequest = true;\r",
							"        }\r",
							"        break;\r",
							"    case 'putwithpname':\r",
							"        if (currentRequestName.toLowerCase() == 'update programs with program name') {\r",
							"            executeRequest = true;\r",
							"        }\r",
							"        break;\r",
							"    case 'deletewithpid':\r",
							"        if (currentRequestName.toLowerCase() == 'delete a program using program id') {\r",
							"            executeRequest = true;\r",
							"        }\r",
							"        break;\r",
							"    case 'deletewithpname':\r",
							"        if (currentRequestName.toLowerCase() == 'delete a program using program name') {\r",
							"            executeRequest = true;\r",
							"        }\r",
							"        break;\r",
							"    default:\r",
							"        console.log(\"Unknown operation type. Skipping request.\");\r",
							"        executeRequest = false;\r",
							"}\r",
							"\r",
							"// If the request should be skipped, move to the next request\r",
							"if (executeRequest == false) {\r",
							"    pm.execution.skipRequest();\r",
							"}"
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"packages": {},
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "BatchModule",
			"item": [
				{
					"name": "BatchScenarios",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Retrieve the requiresAuth flag from the current iteration data\r",
									"var requiresAuth_check = pm.iterationData.get(\"requiresAuth\");\r",
									"\r",
									"// Retrieve the global access token\r",
									"var token = pm.globals.get(\"access_token\");\r",
									"\r",
									"// Function to handle \"null\" strings and convert them to actual null\r",
									"function handleNull(value) {\r",
									"    return (value === \"null\" || value === undefined) ? null : value;\r",
									"}\r",
									"\r",
									"\r",
									"// Retrieve and process global and iteration data for constructing the request body\r",
									"var programId = handleNull(pm.collectionVariables.get(\"ProgramId\"));\r",
									"var programName = handleNull(pm.collectionVariables.get(\"ProgramName\"));\r",
									"var batchDescription = handleNull(pm.iterationData.get(\"batchDescription\"));\r",
									"var batchName = handleNull(pm.iterationData.get(\"batchName\"));\r",
									"var batchNoOfClasses = handleNull(pm.iterationData.get(\"batchNoOfClasses\"));\r",
									"var batchStatus = handleNull(pm.iterationData.get(\"batchStatus\"));\r",
									"var inactiveprogramId = handleNull(pm.collectionVariables.get(\"InactiveProgramId\"));\r",
									"// Construct the request body\r",
									"if(pm.iterationData.get(\"scenarioName\")===\"InactiveProgramId\"){\r",
									"var requestBody = {\r",
									"    \"batchDescription\": batchDescription,\r",
									"    \"batchName\": batchName,\r",
									"    \"batchNoOfClasses\": batchNoOfClasses,\r",
									"    \"batchStatus\": batchStatus,\r",
									"    \"programId\": inactiveprogramId ,\r",
									"    \"programName\": programName\r",
									"};\r",
									"}else{\r",
									"\r",
									"var requestBody = {\r",
									"    \"batchDescription\": batchDescription,\r",
									"    \"batchName\": batchName,\r",
									"    \"batchNoOfClasses\": batchNoOfClasses,\r",
									"    \"batchStatus\": batchStatus,\r",
									"    \"programId\": programId,\r",
									"    \"programName\": programName\r",
									"};\r",
									"}\r",
									"// Set the request body as a global variable for further use\r",
									"pm.globals.set(\"requestBody\", JSON.stringify(requestBody));\r",
									"\r",
									"\r",
									"\r",
									"\r",
									"// Check if the current iteration requires authentication and the token exists\r",
									"if (requiresAuth_check === true && token) {\r",
									"    // Add the Authorization header for bearer token\r",
									"    pm.request.headers.upsert({\r",
									"        key: \"Authorization\",\r",
									"        value: \"Bearer \" + token\r",
									"    });\r",
									"    console.log(\"Authorization header set with token.\");\r",
									"} else {\r",
									"    // If no authentication is required, ensure the Authorization header is not set\r",
									"    pm.request.headers.upsert({\r",
									"        key: \"Authorization\",\r",
									"        value: \"\"\r",
									"    });\r",
									"    console.log(\"Authorization header removed.\");\r",
									"}\r",
									"\r",
									"\r",
									"\r",
									"\r",
									"var isValidEndpoint = pm.iterationData.get(\"endpoint\");\r",
									"\r",
									"\r",
									"var baseUrl = pm.globals.get(\"baseurl\");\r",
									"\r",
									"\r",
									"var validPath = \"/batches\";  \r",
									"var invalidPath = \"/batc\";  \r",
									"\r",
									"if (isValidEndpoint === \"batches\") {\r",
									"    pm.request.url = baseUrl + validPath;\r",
									"    console.log(\"Using valid endpoint:\", baseUrl + validPath);\r",
									"} else {\r",
									"    pm.request.url = baseUrl + invalidPath;\r",
									"    console.log(\"Using invalid endpoint:\", baseUrl + invalidPath);\r",
									"}\r",
									"\r",
									"\r",
									"\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"var expectbatchDescription=pm.iterationData.get(\"batchDescription\");\r",
									"var expectbatchName=pm.iterationData.get(\"batchName\");\r",
									"var expectbatchNoOfClasses=pm.iterationData.get(\"batchNoOfClasses\");\r",
									"var expectbatchStatus=pm.iterationData.get(\"batchStatus\");\r",
									"var testType = pm.iterationData.get(\"testtype\");\r",
									"var status_code=pm.iterationData.get(\"statuscode\");\r",
									"var scenarioName=pm.iterationData.get(\"scenarioName\");\r",
									"var programName = pm.collectionVariables.get(\"ProgramName\");\r",
									"var expectedExistmsg = `Program ${programName} with Batch-${expectbatchName} already exists`;\r",
									"var expectedinvalidMsg='batchName Please provide a valid name and must begin with letter and can have letters,numbers and sometimes hyphens';\r",
									"\r",
									"\r",
									"\r",
									"\r",
									"\r",
									"\r",
									"if (pm.iterationData.get(\"requesttype\") === \"Post\") {\r",
									"if ((testType === \"Positive\" && status_code === 201 && (scenarioName === \"ValidData\" || scenarioName === \"MissingAdditionalFields\"))){ \r",
									"    var responseBody=pm.response.json();\r",
									"var batchId = responseBody.batchId;\r",
									"var batchName = pm.iterationData.get(\"batchName\");\r",
									"    pm.collectionVariables.set('batchId', batchId);\r",
									"    pm.collectionVariables.set('batchName', batchName);\r",
									"pm.test(\"Store batchId and batchName in collection variables\", function () {\r",
									"   \r",
									"    \r",
									"    // Get current iteration number\r",
									"    const iteration = pm.info.iteration;\r",
									"    \r",
									"    // Set unique collection variables for batchId and batchName\r",
									"    pm.collectionVariables.set(`batchId_${iteration}`, responseBody.batchId);\r",
									"    pm.collectionVariables.set(`batchName_${iteration}`, responseBody.batchName);\r",
									"\r",
									"    console.log(`Stored batchId and batchName for iteration ${iteration}`);\r",
									"});\r",
									"\r",
									"// Log stored values for verification (optional)\r",
									"console.log(`batchId_${pm.info.iteration}: `, pm.collectionVariables.get(`batchId_${pm.info.iteration}`));\r",
									"console.log(`batchName_${pm.info.iteration}: `, pm.collectionVariables.get(`batchName_${pm.info.iteration}`));\r",
									"\r",
									"\r",
									"\r",
									"     pm.test(\"Status code is 201 Created\", function () {\r",
									"        pm.response.to.have.status(201);\r",
									"    });\r",
									"    pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Created\");\r",
									"    });\r",
									"\r",
									"    pm.test(\"Content-Type is present\", function () {\r",
									"        pm.response.to.have.header(\"Content-Type\");\r",
									"    });\r",
									" pm.test(\"Verify batchDescription\", function () {\r",
									"    pm.expect(responseBody.batchDescription).to.eql(pm.iterationData.get(\"batchDescription\"));\r",
									" });\r",
									"\r",
									" pm.test(\"Verify batchName\", function () {\r",
									"    pm.expect(responseBody.batchName).to.eql(pm.iterationData.get(\"batchName\"));\r",
									" });\r",
									"   pm.test(\"Verify batchNoOfClasses\", function () {\r",
									"    pm.expect(responseBody.batchNoOfClasses).to.eql(pm.iterationData.get(\"batchNoOfClasses\"));\r",
									"});\r",
									"pm.test(\"Verify batch status\", function () {\r",
									"    pm.expect(responseBody.batchStatus).to.eql(pm.iterationData.get(\"batchStatus\"));\r",
									"});\r",
									"\r",
									" // Schema Validation\r",
									"        const schema = {\r",
									"            \"type\": \"object\",\r",
									"            \"properties\": {\r",
									"                \"batchId\": { \"type\": \"integer\" },\r",
									"                \"batchName\": { \"type\": \"string\" },\r",
									"                \"batchDescription\": { \"type\": \"string\" },\r",
									"                \"batchStatus\": { \"type\": \"string\" },\r",
									"                \"batchNoOfClasses\": { \"type\": \"integer\" },\r",
									"                \"programId\": { \"type\": \"integer\" },\r",
									"                \"programName\": { \"type\": \"string\" }\r",
									"            },\r",
									"            \"required\": [\"batchId\", \"batchName\", \"batchDescription\", \"batchStatus\", \"batchNoOfClasses\", \"programId\", \"programName\"]\r",
									"        };\r",
									"\r",
									"        pm.test(\"Response JSON schema is valid\", function () {\r",
									"            pm.response.to.have.jsonSchema(schema);\r",
									"        });\r",
									"    }\r",
									"\r",
									"\r",
									"\r",
									"\r",
									"if (testType === \"Negative\" && status_code===401 && scenarioName===\"Unauthorized\") { \r",
									"    if (pm.response.code === 401) {\r",
									"    console.log(\"Unauthorized request - skipping JSON parsing and message validation.\");\r",
									"    pm.test(\"Should return 401 for unauthorized request\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(401);\r",
									"    });\r",
									"}\r",
									"}\r",
									"if (testType === \"Negative\" && status_code===400  && scenarioName===\"ExistingBatchName\") { \r",
									"     pm.test(\"Status code is 400\", function () {\r",
									"        pm.response.to.have.status(400);\r",
									"    });\r",
									"    pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Bad Request\");\r",
									"    });\r",
									"\r",
									"\r",
									"\r",
									"pm.test(\"Error message should contain program and batch name\", function () {\r",
									"     var responseBody=pm.response.json();\r",
									"    var actualexisitingMessage = responseBody.message;\r",
									"    pm.expect(actualexisitingMessage).to.include(expectedExistmsg); \r",
									"});\r",
									"\r",
									"}\r",
									"\r",
									"\r",
									"if (testType === \"Negative\" && status_code===404 && scenarioName===\"InvalidEndpoint\" ) { \r",
									"     pm.test(\"Status code is 404\", function () {\r",
									"        pm.response.to.have.status(404);\r",
									"    });\r",
									"    pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Not Found\");\r",
									"    });\r",
									"   pm.test(\"Error message Invalid Endpoint\", function () {\r",
									"    pm.expect(pm.response.text()).to.include(\"Invalid endpoint\"); \r",
									"});\r",
									"}\r",
									"\r",
									"\r",
									"if (testType === \"Negative\" && status_code===400  && scenarioName===\"MissingMandatoryFields\") { \r",
									"     pm.test(\"Status code is 400\", function () {\r",
									"        pm.response.to.have.status(400);\r",
									"    });\r",
									"    pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Bad Request\");\r",
									"    });\r",
									"     pm.test(\"Error message success false\", function () {\r",
									"         var responseBody=pm.response.json();\r",
									"   pm.expect(responseBody.success).to.eql(false);\r",
									"});\r",
									"}\r",
									"\r",
									"if (testType === \"Negative\" && status_code===400  && scenarioName===\"InvalidData\") { \r",
									"     pm.test(\"Status code is 400\", function () {\r",
									"        pm.response.to.have.status(400);\r",
									"    });\r",
									"    pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Bad Request\");\r",
									"    });\r",
									"\r",
									"pm.test(\"Error message should message\", function () {\r",
									"     var responseBody=pm.response.json();\r",
									"    var actualinvalidMsg=responseBody.message;\r",
									"    pm.expect(actualinvalidMsg).to.include(expectedinvalidMsg); \r",
									"});\r",
									" pm.test(\"Error message success false\", function () {\r",
									"    var responseBody=pm.response.json();\r",
									"   pm.expect(responseBody.success).to.eql(false);\r",
									"});\r",
									"\r",
									"}\r",
									"if (testType === \"Negative\" && status_code===400  && scenarioName===\"InactiveProgramId\") { \r",
									"     pm.test(\"Status code is 400\", function () {\r",
									"        pm.response.to.have.status(400);\r",
									"    });\r",
									"    pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Bad Request\");\r",
									"    });\r",
									"\r",
									"    pm.test(\"Error message should message\", function () {\r",
									"         var responseBody=pm.response.json();\r",
									"        var actualinvalidProgramIdmsg=responseBody.message;\r",
									"  pm.expect(actualinvalidProgramIdmsg).to.include(\" ProgramId should be a positive number \");\r",
									"});\r",
									" pm.test(\"Error message success false\", function () {\r",
									"     var responseBody=pm.response.json();\r",
									"   pm.expect(responseBody.success).to.eql(false);\r",
									"});\r",
									"\r",
									"}\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{requestBody}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseurl}}/batches",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"batches"
							]
						}
					},
					"response": []
				},
				{
					"name": "AllBatches",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"const response = pm.response.json();\r",
									"pm.test(\"Should return 200 for unauthorized request\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(200);\r",
									"    });\r",
									" \r",
									" pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"OK\");\r",
									"    });\r",
									"//header validation\r",
									"pm.test(\"Header validation\", () => {\r",
									"    pm.response.to.have.header(\"Content-Type\");\r",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');\r",
									"});\r",
									"\r",
									"if (pm.response.code === 200) {\r",
									"    pm.test(\"validate response body properties\", () => {\r",
									"        // Check the expected properties exist\r",
									"        pm.expect(pm.response.text()).to.include(\"batchId\");\r",
									"        pm.expect(pm.response.text()).to.include(\"batchName\");\r",
									"        pm.expect(pm.response.text()).to.include(\"batchDescription\");\r",
									"        pm.expect(pm.response.text()).to.include(\"batchStatus\");\r",
									"        pm.expect(pm.response.text()).to.include(\"batchNoOfClasses\");\r",
									"        pm.expect(pm.response.text()).to.include(\"programId\");\r",
									"        pm.expect(pm.response.text()).to.include(\"programName\");\r",
									"    });\r",
									"\r",
									"    pm.test(\"validate response body datatypes\", () => {\r",
									"    pm.expect(response).to.be.an(\"array\"); \r",
									"    \r",
									"    response.forEach((item) => {\r",
									"        pm.expect(item.batchId).to.be.a(\"number\");\r",
									"        pm.expect(item.batchName).to.be.a(\"string\", \"batchName should be a string\").and.to.not.be.null;\r",
									"          pm.expect(item.batchDescription).to.satisfy(desc => typeof desc === \"string\" || desc === null, \"batchDescription should be a string or null\");\r",
									"        pm.expect(item.batchStatus).to.be.a(\"string\")\r",
									"\r",
									"        pm.expect(item.batchNoOfClasses).to.be.a(\"number\");\r",
									"        pm.expect(Number.isInteger(item.batchNoOfClasses)).to.be.true;\r",
									"\r",
									"        pm.expect(item.programId).to.be.a(\"number\");\r",
									"        pm.expect(Number.isInteger(item.programId)).to.be.true;\r",
									"\r",
									"        pm.expect(item.programName).to.be.a(\"string\", \"programName should be a string\").and.to.not.be.null;\r",
									"    });\r",
									"});\r",
									"\r",
									"//schema validation \r",
									"\r",
									"const schema = {\r",
									"    \"type\": \"array\",\r",
									"    \"items\": {\r",
									"        \"type\": \"object\",\r",
									"        \"properties\": {\r",
									"            \"batchId\": { \"type\": \"number\" },\r",
									"            \"batchName\": { \"type\": \"string\" },\r",
									"            \"batchDescription\": { \r",
									"                \"type\": [\"string\", \"null\"] \r",
									"            },\r",
									"            \"batchStatus\": { \r",
									"                \"type\": \"string\"\r",
									"            },\r",
									"            \"batchNoOfClasses\": { \"type\": \"integer\" },\r",
									"            \"programId\": { \"type\": \"integer\" },\r",
									"            \"programName\": { \"type\": \"string\" }\r",
									"        },\r",
									"        \"required\": [\r",
									"            \"batchId\",\r",
									"            \"batchName\",\r",
									"            \"batchStatus\",\r",
									"            \"batchNoOfClasses\",\r",
									"            \"programId\",\r",
									"            \"programName\"\r",
									"        ]\r",
									"    }\r",
									"};\r",
									"\r",
									"pm.test(\"Response JSON schema is valid\", function () {\r",
									"            pm.response.to.have.jsonSchema(schema);\r",
									"        });\r",
									"\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/batches",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"batches"
							]
						}
					},
					"response": []
				},
				{
					"name": "AllBatchesWithInvalidEndpoint",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Should return 404 for not found\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(404);\r",
									"    });\r",
									" \r",
									" pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Not Found\");\r",
									"    });\r",
									"\r",
									"\r",
									" pm.test(\"Error message Invalid Endpoint\", function () {\r",
									"    pm.expect(responseBody).to.include(\"Invalid endpoint\"); \r",
									"});\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/batc",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"batc"
							]
						}
					},
					"response": []
				},
				{
					"name": "AllBatchesWithSearchString",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Should return 200 for unauthorized request\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(200);\r",
									"    });\r",
									" \r",
									" pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"OK\");\r",
									"    });\r",
									"\r",
									"    //header validation\r",
									"pm.test(\"Header validation\", () => {\r",
									"    pm.response.to.have.header(\"Content-Type\");\r",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');\r",
									"});\r",
									"\r",
									"//schema validation\r",
									"\r",
									"const schema = {\r",
									"    \"type\": \"array\",\r",
									"    \"items\": {\r",
									"        \"type\": \"object\",\r",
									"        \"properties\": {\r",
									"            \"batchId\": { \"type\": \"number\" },\r",
									"            \"batchName\": { \"type\": \"string\" },\r",
									"            \"batchDescription\": { \r",
									"                \"type\": [\"string\", \"null\"] \r",
									"            },\r",
									"            \"batchStatus\": { \r",
									"                \"type\": \"string\"\r",
									"            },\r",
									"            \"batchNoOfClasses\": { \"type\": \"integer\" },\r",
									"            \"programId\": { \"type\": \"integer\" },\r",
									"            \"programName\": { \"type\": \"string\" }\r",
									"        },\r",
									"        \"required\": [\r",
									"            \"batchId\",\r",
									"            \"batchName\",\r",
									"            \"batchStatus\",\r",
									"            \"batchNoOfClasses\",\r",
									"            \"programId\",\r",
									"            \"programName\"\r",
									"        ]\r",
									"    }\r",
									"};\r",
									"\r",
									"pm.test(\"Response JSON schema is valid\", function () {\r",
									"            pm.response.to.have.jsonSchema(schema);\r",
									"        });\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/batches?batchDescription={{batchDescription}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"batches"
							],
							"query": [
								{
									"key": "batchDescription",
									"value": "{{batchDescription}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "AllBatchesWithNoAuth",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"\r",
									"    pm.test(\"Should return 401 for unauthorized request\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(401);\r",
									"    });\r",
									"     pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Unauthorized\");\r",
									"    });\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/batches",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"batches"
							]
						}
					},
					"response": []
				},
				{
					"name": "BatchWithBatchIdWithoutAuth",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"\r",
									"    pm.test(\"Should return 401 for unauthorized request\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(401);\r",
									"    });\r",
									"     pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Unauthorized\");\r",
									"    });\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{baseurl}}/batches/batchId/{{batchId_23}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"batches",
								"batchId",
								"{{batchId_23}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "BatchWithValidBatchId",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"\r",
									"   const response=pm.response.json();\r",
									"    pm.test(\"Should return 200 for valid request\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(200);\r",
									"    });\r",
									"     pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"OK\");\r",
									"    });\r",
									"\r",
									"    //header validation\r",
									"pm.test(\"Header validation\", () => {\r",
									"    pm.response.to.have.header(\"Content-Type\");\r",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');\r",
									"});\r",
									"\r",
									"if (pm.response.code === 200) {\r",
									"    pm.test(\"validate response body properties\", () => {\r",
									"        // Check the expected properties exist\r",
									"        pm.expect(pm.response.text()).to.include(\"batchId\");\r",
									"        pm.expect(pm.response.text()).to.include(\"batchName\");\r",
									"        pm.expect(pm.response.text()).to.include(\"batchDescription\");\r",
									"        pm.expect(pm.response.text()).to.include(\"batchStatus\");\r",
									"        pm.expect(pm.response.text()).to.include(\"batchNoOfClasses\");\r",
									"        pm.expect(pm.response.text()).to.include(\"programId\");\r",
									"        pm.expect(pm.response.text()).to.include(\"programName\");\r",
									"    });\r",
									"\r",
									"    pm.test(\"validate response body datatypes\", () => {\r",
									"        pm.expect(response.batchId).to.be.a(\"number\");\r",
									"        pm.expect(Number.isInteger(response.batchId)).to.be.true;\r",
									"        pm.expect(response.batchName).to.be.a(\"string\", \"batchName should be a string\").and.to.not.be.null;\r",
									"          pm.expect(response.batchDescription).to.satisfy(desc => typeof desc === \"string\" || desc === null, \"batchDescription should be a string or null\");\r",
									"        pm.expect(response.batchStatus).to.be.a(\"string\")\r",
									"        pm.expect(response.batchNoOfClasses).to.be.a(\"number\");\r",
									"        pm.expect(Number.isInteger(response.batchNoOfClasses)).to.be.true;\r",
									"        pm.expect(response.programId).to.be.a(\"number\");\r",
									"        pm.expect(Number.isInteger(response.programId)).to.be.true;\r",
									"\r",
									"        pm.expect(response.programName).to.be.a(\"string\", \"programName should be a string\").and.to.not.be.null;\r",
									"});\r",
									"\r",
									"// Schema validation\r",
									"const schema = {\r",
									"    \"type\": \"object\",\r",
									"    \"properties\": {\r",
									"        \"batchId\": { \"type\": \"integer\" },\r",
									"        \"batchName\": { \"type\": \"string\" },\r",
									"        \"batchDescription\": { \"type\": \"string\" },\r",
									"        \"batchStatus\": { \r",
									"            \"type\": \"string\",\r",
									"            \"enum\": [\"Active\", \"Inactive\"]  // Only allow these specific values\r",
									"        },\r",
									"        \"batchNoOfClasses\": { \"type\": \"integer\" },\r",
									"        \"programId\": { \"type\": \"integer\" },\r",
									"        \"programName\": { \"type\": \"string\" }\r",
									"    },\r",
									"    \"required\": [\"batchId\", \"batchName\", \"batchDescription\", \"batchStatus\", \"batchNoOfClasses\", \"programId\", \"programName\"]\r",
									"};\r",
									"\r",
									"// Validate the response body against the schema\r",
									"pm.test(\"Response matches the expected schema\", function () {\r",
									"    pm.response.to.have.jsonSchema(schema);\r",
									"});\r",
									"\r",
									"\r",
									"\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{baseurl}}/batches/batchId/{{batchId_23}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"batches",
								"batchId",
								"{{batchId_23}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "BatchWithInvalidBatchId",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"\r",
									"var responseBody=pm.response.json();\r",
									"    pm.test(\"Should return 404 for invalid request\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(404);\r",
									"    });\r",
									"     pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Not Found\");\r",
									"    });\r",
									"\r",
									"    //header validation\r",
									"pm.test(\"Header validation\", () => {\r",
									"    pm.response.to.have.header(\"Content-Type\");\r",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');\r",
									"});\r",
									"\r",
									" pm.test(\"Error message success false\", function () {\r",
									"   pm.expect(responseBody.success).to.eql(false);\r",
									"});\r",
									"pm.test(\"Response contains invalid Batch id\", function () {\r",
									"\r",
									"    const responseText = pm.response.text();\r",
									"    const expectedBatchId = pm.collectionVariables.get(\"invalidbatchId\"); \r",
									"pm.expect(responseText).to.include(`Id : ${expectedBatchId}`);\r",
									"    \r",
									"});\r",
									"\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{baseurl}}/batches/batchId/{{invalidbatchId}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"batches",
								"batchId",
								"{{invalidbatchId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "BatchIdWithInvalidEndpoint",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Should return 404 for not found\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(404);\r",
									"    });\r",
									" \r",
									" pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Not Found\");\r",
									"    });\r",
									"\r",
									"\r",
									" pm.test(\"Error message Invalid Endpoint\", function () {\r",
									"    pm.expect(responseBody).to.include(\"Invalid endpoint\"); \r",
									"});\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{baseurl}}/batches/batch/{{batchId_23}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"batches",
								"batch",
								"{{batchId_23}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "BatchWithBatchNameNoAuth",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"\r",
									"    pm.test(\"Should return 401 for unauthorized request\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(401);\r",
									"    });\r",
									"     pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Unauthorized\");\r",
									"    });\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{baseurl}}/batches/batchName/{{batchName_24}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"batches",
								"batchName",
								"{{batchName_24}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "BatchWithValidBatchname",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"\r",
									"   const response=pm.response.json();\r",
									"    pm.test(\"Should return 200 for valid request\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(200);\r",
									"    });\r",
									"     pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"OK\");\r",
									"    });\r",
									"\r",
									"    //header validation\r",
									"pm.test(\"Header validation\", () => {\r",
									"    pm.response.to.have.header(\"Content-Type\");\r",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');\r",
									"});\r",
									"\r",
									"if (pm.response.code === 200) {\r",
									"    pm.test(\"validate response body properties\", () => {\r",
									"        // Check the expected properties exist\r",
									"        pm.expect(pm.response.text()).to.include(\"batchId\");\r",
									"        pm.expect(pm.response.text()).to.include(\"batchName\");\r",
									"        pm.expect(pm.response.text()).to.include(\"batchDescription\");\r",
									"        pm.expect(pm.response.text()).to.include(\"batchStatus\");\r",
									"        pm.expect(pm.response.text()).to.include(\"batchNoOfClasses\");\r",
									"        pm.expect(pm.response.text()).to.include(\"programId\");\r",
									"        pm.expect(pm.response.text()).to.include(\"programName\");\r",
									"    });\r",
									"\r",
									"    pm.test(\"validate response body datatypes\", () => {\r",
									"    pm.expect(response).to.be.an(\"array\"); \r",
									"    \r",
									"    response.forEach((item) => {\r",
									"        pm.expect(item.batchId).to.be.a(\"number\");\r",
									"        pm.expect(Number.isInteger(item.batchId)).to.be.true;\r",
									"\r",
									"        pm.expect(item.batchName).to.be.a(\"string\", \"batchName should be a string\").and.to.not.be.null;\r",
									"          pm.expect(item.batchDescription).to.satisfy(desc => typeof desc === \"string\" || desc === null, \"batchDescription should be a string or null\");\r",
									"        pm.expect(item.batchStatus).to.be.a(\"string\")\r",
									"\r",
									"        pm.expect(item.batchNoOfClasses).to.be.a(\"number\");\r",
									"        pm.expect(Number.isInteger(item.batchNoOfClasses)).to.be.true;\r",
									"\r",
									"        pm.expect(item.programId).to.be.a(\"number\");\r",
									"        pm.expect(Number.isInteger(item.programId)).to.be.true;\r",
									"\r",
									"        pm.expect(item.programName).to.be.a(\"string\", \"programName should be a string\").and.to.not.be.null;\r",
									"    });\r",
									"});\r",
									"\r",
									"//schema validation \r",
									"\r",
									"const schema = {\r",
									"    \"type\": \"array\",\r",
									"    \"items\": {\r",
									"        \"type\": \"object\",\r",
									"        \"properties\": {\r",
									"            \"batchId\": { \"type\": \"number\" },\r",
									"            \"batchName\": { \"type\": \"string\" },\r",
									"            \"batchDescription\": { \r",
									"                \"type\": [\"string\", \"null\"] \r",
									"            },\r",
									"            \"batchStatus\": { \r",
									"                \"type\": \"string\"\r",
									"            },\r",
									"            \"batchNoOfClasses\": { \"type\": \"integer\" },\r",
									"            \"programId\": { \"type\": \"integer\" },\r",
									"            \"programName\": { \"type\": \"string\" }\r",
									"        },\r",
									"        \"required\": [\r",
									"            \"batchId\",\r",
									"            \"batchName\",\r",
									"            \"batchStatus\",\r",
									"            \"batchNoOfClasses\",\r",
									"            \"programId\",\r",
									"            \"programName\"\r",
									"        ]\r",
									"    }\r",
									"};\r",
									"\r",
									"pm.test(\"Response JSON schema is valid\", function () {\r",
									"            pm.response.to.have.jsonSchema(schema);\r",
									"        });\r",
									"\r",
									"}\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{baseurl}}/batches/batchName/{{batchName_24}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"batches",
								"batchName",
								"{{batchName_24}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "BatchWithInValidBatchname",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"\r",
									"var responseBody=pm.response.json();\r",
									"    pm.test(\"Should return 404 for invalid request\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(404);\r",
									"    });\r",
									"     pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Not Found\");\r",
									"    });\r",
									"\r",
									"    //header validation\r",
									"pm.test(\"Header validation\", () => {\r",
									"    pm.response.to.have.header(\"Content-Type\");\r",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');\r",
									"});\r",
									"\r",
									" pm.test(\"Error message success false\", function () {\r",
									"   pm.expect(responseBody.success).to.eql(false);\r",
									"});\r",
									"pm.test(\"Validate response body with invalid batch name\", function () {\r",
									"    const expectedBatchName = pm.collectionVariables.get(\"invalidBatchName\");\r",
									"    const expectedMessage = `programBatch with name ${expectedBatchName} not found`;\r",
									"\r",
									"    pm.expect(responseBody.message).to.equal(expectedMessage);\r",
									"});\r",
									"\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{baseurl}}/batches/batchName/{{invalidBatchName}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"batches",
								"batchName",
								"{{invalidBatchName}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "BatchNameWithInvalidEndpoint",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody=pm.response.json();\r",
									"pm.test(\"Should return 404 for not found\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(404);\r",
									"    });\r",
									" \r",
									" pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Not Found\");\r",
									"    });\r",
									"\r",
									"\r",
									" pm.test(\"Error message Invalid Endpoint\", function () {\r",
									"    pm.expect(responseBody).to.include(\"Invalid endpoint\"); \r",
									"});\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{baseurl}}/batc/batchName/{{batchName_24}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"batc",
								"batchName",
								"{{batchName_24}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "BatchWithProgramIdNoAuth",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"\r",
									"    pm.test(\"Should return 401 for unauthorized request\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(401);\r",
									"    });\r",
									"     pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Unauthorized\");\r",
									"    });\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseurl}}/batches/program/{{ProgramId}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"batches",
								"program",
								"{{ProgramId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "BatchWithValidProgramId",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"\r",
									"   const response=pm.response.json();\r",
									"    pm.test(\"Should return 200 for valid request\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(200);\r",
									"    });\r",
									"     pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"OK\");\r",
									"    });\r",
									"\r",
									"    //header validation\r",
									"pm.test(\"Header validation\", () => {\r",
									"    pm.response.to.have.header(\"Content-Type\");\r",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');\r",
									"});\r",
									"\r",
									"if (pm.response.code === 200) {\r",
									"    pm.test(\"validate response body properties\", () => {\r",
									"        // Check the expected properties exist\r",
									"        pm.expect(pm.response.text()).to.include(\"batchId\");\r",
									"        pm.expect(pm.response.text()).to.include(\"batchName\");\r",
									"        pm.expect(pm.response.text()).to.include(\"batchDescription\");\r",
									"        pm.expect(pm.response.text()).to.include(\"batchStatus\");\r",
									"        pm.expect(pm.response.text()).to.include(\"batchNoOfClasses\");\r",
									"        pm.expect(pm.response.text()).to.include(\"programId\");\r",
									"        pm.expect(pm.response.text()).to.include(\"programName\");\r",
									"    });\r",
									"\r",
									"    pm.test(\"validate response body datatypes\", () => {\r",
									"    pm.expect(response).to.be.an(\"array\"); \r",
									"    \r",
									"    response.forEach((item) => {\r",
									"        pm.expect(item.batchId).to.be.a(\"number\");\r",
									"        pm.expect(Number.isInteger(item.batchId)).to.be.true;\r",
									"\r",
									"        pm.expect(item.batchName).to.be.a(\"string\", \"batchName should be a string\").and.to.not.be.null;\r",
									"          pm.expect(item.batchDescription).to.satisfy(desc => typeof desc === \"string\" || desc === null, \"batchDescription should be a string or null\");\r",
									"        pm.expect(item.batchStatus).to.be.a(\"string\")\r",
									"\r",
									"        pm.expect(item.batchNoOfClasses).to.be.a(\"number\");\r",
									"        pm.expect(Number.isInteger(item.batchNoOfClasses)).to.be.true;\r",
									"\r",
									"        pm.expect(item.programId).to.be.a(\"number\");\r",
									"        pm.expect(Number.isInteger(item.programId)).to.be.true;\r",
									"\r",
									"        pm.expect(item.programName).to.be.a(\"string\", \"programName should be a string\").and.to.not.be.null;\r",
									"    });\r",
									"});\r",
									"\r",
									"//schema validation \r",
									"\r",
									"const schema = {\r",
									"    \"type\": \"array\",\r",
									"    \"items\": {\r",
									"        \"type\": \"object\",\r",
									"        \"properties\": {\r",
									"            \"batchId\": { \"type\": \"number\" },\r",
									"            \"batchName\": { \"type\": \"string\" },\r",
									"            \"batchDescription\": { \r",
									"                \"type\": [\"string\", \"null\"] \r",
									"            },\r",
									"            \"batchStatus\": { \r",
									"                \"type\": \"string\"\r",
									"            },\r",
									"            \"batchNoOfClasses\": { \"type\": \"integer\" },\r",
									"            \"programId\": { \"type\": \"integer\" },\r",
									"            \"programName\": { \"type\": \"string\" }\r",
									"        },\r",
									"        \"required\": [\r",
									"            \"batchId\",\r",
									"            \"batchName\",\r",
									"            \"batchStatus\",\r",
									"            \"batchNoOfClasses\",\r",
									"            \"programId\",\r",
									"            \"programName\"\r",
									"        ]\r",
									"    }\r",
									"};\r",
									"\r",
									"pm.test(\"Response JSON schema is valid\", function () {\r",
									"            pm.response.to.have.jsonSchema(schema);\r",
									"        });\r",
									"\r",
									"\r",
									"\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseurl}}/batches/program/{{ProgramId}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"batches",
								"program",
								"{{ProgramId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "BatchWithInvalidProgramId",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"\r",
									"var responseBody=pm.response.json();\r",
									"    pm.test(\"Should return 404 for invalid request\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(404);\r",
									"    });\r",
									"     pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Not Found\");\r",
									"    });\r",
									"\r",
									"    //header validation\r",
									"pm.test(\"Header validation\", () => {\r",
									"    pm.response.to.have.header(\"Content-Type\");\r",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');\r",
									"});\r",
									"\r",
									" pm.test(\"Error message success false\", function () {\r",
									"   pm.expect(responseBody.success).to.eql(false);\r",
									"});\r",
									"pm.test(\"Response contains invalid Program id\", function () {\r",
									"\r",
									"    const responseText = pm.response.text();\r",
									"    const expectedProgramId = pm.collectionVariables.get(\"invalidProgramId\"); \r",
									"pm.expect(responseText).to.include(`programId ${expectedProgramId}`);\r",
									"    \r",
									"});\r",
									"\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseurl}}/batches/program/{{invalidProgramId}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"batches",
								"program",
								"{{invalidProgramId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "BatchWithInvalidEndpointProgramId",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Should return 404 for not found\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(404);\r",
									"    });\r",
									" \r",
									" pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Not Found\");\r",
									"    });\r",
									"\r",
									"\r",
									" pm.test(\"Error message Invalid Endpoint\", function () {\r",
									"    pm.expect(responseBody).to.include(\"Invalid endpoint\"); \r",
									"});\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseurl}}/batchs/program/{{ProgramId}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"batchs",
								"program",
								"{{ProgramId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "UpdateByBatchID",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"//Function to handle \"null\" strings and convert empty/undefined values to null\r",
									"function handleNull(value) {\r",
									"    return (value === \"null\" || value === undefined || value === \"\") ? null : value;\r",
									"}\r",
									"// Retrieve and process global and iteration data for constructing the request body\r",
									"var programId = handleNull(pm.collectionVariables.get(\"ProgramId\"));\r",
									"var programName = handleNull(pm.collectionVariables.get(\"ProgramName\"));\r",
									"var batchDescription = handleNull(pm.iterationData.get(\"batchDescription_put\"));\r",
									"var batchName = handleNull(pm.iterationData.get(\"batchName_put\"));\r",
									"var batchNoOfClasses = handleNull(pm.iterationData.get(\"batchNoOfClasses_put\"));\r",
									"var batchStatus = handleNull(pm.iterationData.get(\"batchStatus_put\"));\r",
									"var batchId_update = pm.collectionVariables.get(\"batchId_0\");\r",
									"var requiresAuth_check = pm.iterationData.get(\"requiresAuth_put\");\r",
									"var token = pm.globals.get(\"access_token\");\r",
									"var scenarioType = pm.iterationData.get(\"scenarioName_put\");\r",
									"var invalidbatchId = pm.collectionVariables.get(\"invalidbatchId\");\r",
									"console.log(\"Iteration Data: \", pm.iterationData.toObject()); // Log iteration data for debugging\r",
									"// Ensure you have correct values for the first iteration\r",
									"console.log(\"scenarioType: \", scenarioType);\r",
									"console.log(\"batchDescription: \", batchDescription);\r",
									"console.log(\"batchName: \", batchName);\r",
									"// Handling request body based on the scenario type\r",
									"var requestBody;\r",
									"if (scenarioType === \"InvalidBatchId\") {\r",
									"    requestBody = {\r",
									"        \"batchDescription\": batchDescription,\r",
									"        \"batchId\": invalidbatchId,\r",
									"        \"batchName\": batchName,\r",
									"        \"batchNoOfClasses\": batchNoOfClasses,\r",
									"        \"batchStatus\": batchStatus,\r",
									"        \"programId\": programId,\r",
									"        \"programName\": programName\r",
									"    };\r",
									"} else if (scenarioType === \"NullProgramId\") {\r",
									"    requestBody = {\r",
									"        \"batchDescription\": batchDescription,\r",
									"        \"batchId\": batchId_update,\r",
									"        \"batchName\": batchName,\r",
									"        \"batchNoOfClasses\": batchNoOfClasses,\r",
									"        \"batchStatus\": batchStatus,\r",
									"        \"programId\": null,\r",
									"        \"programName\": programName\r",
									"    };\r",
									"} else if (scenarioType === \"NullBatchId\") {\r",
									"    requestBody = {\r",
									"        \"batchDescription\": batchDescription,\r",
									"        \"batchId\": null,\r",
									"        \"batchName\": batchName,\r",
									"        \"batchNoOfClasses\": batchNoOfClasses,\r",
									"        \"batchStatus\": batchStatus,\r",
									"        \"programId\": programId,\r",
									"        \"programName\": programName\r",
									"    };\r",
									"} else {\r",
									"    requestBody = {\r",
									"        \"batchDescription\": batchDescription,\r",
									"        \"batchId\": batchId_update,\r",
									"        \"batchName\": batchName,\r",
									"        \"batchNoOfClasses\": batchNoOfClasses,\r",
									"        \"batchStatus\": batchStatus,\r",
									"        \"programId\": programId,\r",
									"        \"programName\": programName\r",
									"    };\r",
									"}\r",
									"// Only set the request body if it's valid and not empty\r",
									"if (requestBody && Object.keys(requestBody).length > 0) {\r",
									"    pm.globals.set(\"requestBody_put\", JSON.stringify(requestBody));\r",
									"} else {\r",
									"    console.error(\"Request body is empty or invalid.\");\r",
									"}\r",
									"// Handle Authorization\r",
									"if (requiresAuth_check === true && token) {\r",
									"    pm.request.headers.upsert({\r",
									"        key: \"Authorization\",\r",
									"        value: \"Bearer \" + token\r",
									"    });\r",
									"    console.log(\"Authorization header set with token.\");\r",
									"} else {\r",
									"    pm.request.headers.upsert({\r",
									"        key: \"Authorization\",\r",
									"        value: \"\"\r",
									"    });\r",
									"    console.log(\"Authorization header removed.\");\r",
									"}\r",
									"// Construct the request URL based on the endpoint setting\r",
									"var isValidEndpoint = pm.iterationData.get(\"endpoint_put\");\r",
									"var baseUrl = pm.globals.get(\"baseurl\");\r",
									"var validPath = \"/batches\";\r",
									"var invalidPath = \"/batc\";\r",
									"  if(isValidEndpoint === \"batches\" && scenarioType===\"InvalidBatchId\"){\r",
									"pm.request.url = baseUrl + validPath + \"/\" + invalidbatchId ;\r",
									"    console.log(\"Using valid endpoint with invalid batchId:\", pm.request.url.toString());\r",
									"}else if(isValidEndpoint === \"batches\" && scenarioType===\"NullBatchId\"){\r",
									"pm.request.url = baseUrl + validPath + \"/\" + null;\r",
									"    console.log(\"Using valid endpoint with null batchId:\", pm.request.url.toString());\r",
									"}\r",
									"else if (isValidEndpoint === \"batches\") {\r",
									"    pm.request.url = baseUrl + validPath + \"/\" + batchId_update;\r",
									"    console.log(\"Using valid endpoint with batchId:\", pm.request.url.toString());\r",
									"}\r",
									"else {\r",
									"    pm.request.url = baseUrl + invalidPath;\r",
									"    console.log(\"Using invalid endpoint:\", baseUrl + invalidPath);\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"var expectbatchDescription = pm.iterationData.get(\"batchDescription_put\");\r",
									"var expectbatchName = pm.iterationData.get(\"batchName_put\");\r",
									"var expectbatchNoOfClasses = pm.iterationData.get(\"batchNoOfClasses_put\");\r",
									"var expectbatchStatus = pm.iterationData.get(\"batchStatus_put\");\r",
									"var testType = pm.iterationData.get(\"testtype_put\");\r",
									"var status_code = pm.iterationData.get(\"statuscode_put\");\r",
									"var scenarioName = pm.iterationData.get(\"scenarioName_put\");\r",
									"var programName = pm.collectionVariables.get(\"ProgramName\");\r",
									"if (pm.iterationData.get(\"requesttype_put\") === \"Put\") {\r",
									"    if (testType === \"Positive\" && status_code === 200 && scenarioName === \"ValidData\") {\r",
									"          var responseBody=pm.response.json();\r",
									"var batchId = responseBody.batchId;\r",
									"pm.collectionVariables.set(\"batchId\", batchId);\r",
									"pm.collectionVariables.set(\"batchName\", batchName);\r",
									"        pm.test(\"Store batchId and batchName in collection variables\", function () {\r",
									"            const iteration = pm.info.iteration;\r",
									"            pm.collectionVariables.set(`batchIdPut_${iteration}`, responseBody.batchId);\r",
									"            pm.collectionVariables.set(`batchNamePut_${iteration}`, responseBody.batchName);\r",
									"            console.log(`Stored batchId and batchName for iteration ${iteration}`);\r",
									"        });\r",
									"        console.log(`batchIdPut_${pm.info.iteration}: `, pm.collectionVariables.get(`batchIdPut_${pm.info.iteration}`));\r",
									"        console.log(`batchNamePut_${pm.info.iteration}: `, pm.collectionVariables.get(`batchNamePut_${pm.info.iteration}`));\r",
									"        pm.test(\"Status code is 200 Updated\", function () {\r",
									"            pm.response.to.have.status(200);\r",
									"        });\r",
									"        pm.test(\"Status code name has string\", function () {\r",
									"            pm.response.to.have.status(\"OK\");\r",
									"        });\r",
									"        pm.test(\"Content-Type is present\", function () {\r",
									"            pm.response.to.have.header(\"Content-Type\");\r",
									"        });\r",
									"        pm.test(\"Verify batchDescription\", function () {\r",
									"            pm.expect(responseBody.batchDescription).to.eql(expectbatchDescription);\r",
									"        });\r",
									"        pm.test(\"Verify batchName\", function () {\r",
									"            pm.expect(responseBody.batchName).to.eql(expectbatchName);\r",
									"        });\r",
									"        pm.test(\"Verify batchNoOfClasses\", function () {\r",
									"            pm.expect(responseBody.batchNoOfClasses).to.eql(expectbatchNoOfClasses);\r",
									"        });\r",
									"        pm.test(\"Verify batch status\", function () {\r",
									"            pm.expect(responseBody.batchStatus).to.eql(expectbatchStatus);\r",
									"        });\r",
									"        // Schema Validation\r",
									"        const schema = {\r",
									"            \"type\": \"object\",\r",
									"            \"properties\": {\r",
									"                \"batchId\": { \"type\": \"integer\" },\r",
									"                \"batchName\": { \"type\": \"string\" },\r",
									"                \"batchDescription\": { \"type\": \"string\" },\r",
									"                \"batchStatus\": { \"type\": \"string\" },\r",
									"                \"batchNoOfClasses\": { \"type\": \"integer\" },\r",
									"                \"programId\": { \"type\": \"integer\" },\r",
									"                \"programName\": { \"type\": \"string\" }\r",
									"            },\r",
									"            \"required\": [\"batchId\", \"batchName\", \"batchDescription\", \"batchStatus\", \"batchNoOfClasses\", \"programId\", \"programName\"]\r",
									"        };\r",
									"        pm.test(\"Response JSON schema is valid\", function () {\r",
									"            pm.response.to.have.jsonSchema(schema);\r",
									"        });\r",
									"    }\r",
									"}\r",
									"// Negative tests for Unauthorized\r",
									"if (testType === \"Negative\" && status_code === 401 && scenarioName === \"Unauthorized\") {\r",
									"    pm.test(\"Should return 401 for unauthorized request\", function () {\r",
									"        pm.response.to.have.status(401);\r",
									"    });\r",
									"}\r",
									"// Negative test for Null ProgramId\r",
									"if (testType === \"Negative\" && status_code === 400 && scenarioName === \"NullProgramId\") {\r",
									"      var responseBody=pm.response.json();\r",
									"    pm.test(\"Status code is 400\", function () {\r",
									"        pm.response.to.have.status(400);\r",
									"    });\r",
									"    pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Bad Request\");\r",
									"    });\r",
									"    pm.test(\"Validate ProgramId error message\", function () {\r",
									"        pm.expect(responseBody.message).to.eql(\" ProgramId field is needed; It should be a positive number \");\r",
									"    });\r",
									"    pm.test(\"Validate success is false\", function () {\r",
									"        pm.expect(responseBody.success).to.eql(false);\r",
									"    });\r",
									"}\r",
									"// Negative test for Null BatchId\r",
									"if (testType === \"Negative\" && status_code === 400 && scenarioName === \"NullBatchId\") {\r",
									"      var responseBody=pm.response.json();\r",
									"    pm.test(\"Status code is 400\", function () {\r",
									"        pm.response.to.have.status(400);\r",
									"    });\r",
									"    pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Bad Request\");\r",
									"    });\r",
									"    pm.test(\"Validate batch name already exists error message\", function () {\r",
									"        pm.expect(responseBody.message).to.include(\"already exists: ; Please give a different batch Name\");\r",
									"    });\r",
									"    pm.test(\"Validate success is false\", function () {\r",
									"        pm.expect(responseBody.success).to.eql(false);\r",
									"    });\r",
									"}\r",
									"if (testType === \"Negative\" && status_code === 400 && scenarioName === \"InvalidBatchId\") {\r",
									"      var responseBody=pm.response.json();\r",
									"    pm.test(\"Status code is 400\", function () {\r",
									"        pm.response.to.have.status(400);\r",
									"    });\r",
									"    pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Bad Request\");\r",
									"    });\r",
									"    pm.test(\"Validate batch name already exists error message\", function () {\r",
									"        pm.expect(responseBody.message).to.include(\"Batch not found with Id\");\r",
									"    });\r",
									"    pm.test(\"Validate success is false\", function () {\r",
									"        pm.expect(responseBody.success).to.eql(false);\r",
									"    });\r",
									"}\r",
									"// Negative tests for Invalid Endpoint (404)\r",
									"if (testType === \"Negative\" && status_code === 404 && scenarioName === \"InValidEndpoint\") {\r",
									"    pm.test(\"Status code is 404\", function () {\r",
									"        pm.response.to.have.status(404);\r",
									"    });\r",
									"    pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Not Found\");\r",
									"    });\r",
									"    pm.test(\"Error message includes 'Invalid endpoint'\", function () {\r",
									"        pm.expect(pm.response.text()).to.include(\"Invalid endpoint\");\r",
									"    });\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{requestBody_put}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseUrl}}/batches/{{batchId_24}}",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"batches",
								"{{batchId_24}}"
							]
						}
					},
					"response": []
				}
			],
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"packages": {},
						"exec": [
							"const module = pm.iterationData.get('module').trim();\r",
							"console.log(module);\r",
							"\r",
							"if (module.toLowerCase() == 'program') {\r",
							"     pm.execution.skipRequest();       \r",
							"} else {\r",
							"    console.log(\"Module value is either undefined or not 'program':\", module);\r",
							"}\r",
							"\r",
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"packages": {},
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "UserRoleProgramBatchMapController",
			"item": [
				{
					"name": "GetAllUserRoleProgramBatch",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Should return 200 for valid request\", function () {\r",
									"    pm.expect(pm.response.code).to.eql(200);\r",
									"});\r",
									"\r",
									"pm.test(\"Header validation\", () => {\r",
									"    pm.response.to.have.header(\"Content-Type\");\r",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');\r",
									"});\r",
									"\r",
									"pm.test(\"validate response body properties\", () => {\r",
									"    // Check the expected properties exist\r",
									"    pm.expect(response[0]).to.have.property(\"userId\");\r",
									"    pm.expect(response[0]).to.have.property(\"roleId\");\r",
									"    pm.expect(response[0]).to.have.property(\"programId\");\r",
									"    pm.expect(response[0]).to.have.property(\"batchId\");\r",
									"    pm.expect(response[0]).to.have.property(\"userRoleProgramBatchStatus\");\r",
									"});\r",
									"\r",
									"pm.test(\"validate response body datatypes\", () => {\r",
									"    pm.expect(response).to.be.an(\"array\");\r",
									"\r",
									"    response.forEach((item) => {\r",
									"        pm.expect(item.userId).to.be.a('string').and.to.not.be.null;\r",
									"        pm.expect(item.roleId).to.be.a('string');\r",
									"        pm.expect(item.programId).to.be.a('number').and.to.not.be.null;\r",
									"        pm.expect(item.batchId).to.be.a('number').and.to.not.be.null;\r",
									"        pm.expect(item.userRoleProgramBatchStatus).to.be.oneOf(['Active', 'Inactive']);\r",
									"    });\r",
									"});\r",
									"\r",
									"var responseSchema = {\r",
									"    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\r",
									"    \"type\": \"array\",\r",
									"    \"items\": {\r",
									"        \"type\": \"object\",\r",
									"        \"properties\": {\r",
									"            \"userId\": {\r",
									"                \"type\": \"string\"\r",
									"            },\r",
									"            \"roleId\": {\r",
									"                \"type\": \"string\"\r",
									"            },\r",
									"            \"programId\": {\r",
									"                \"type\": \"number\"\r",
									"            },\r",
									"            \"batchId\": {\r",
									"                \"type\": \"number\"\r",
									"            },\r",
									"            \"userRoleProgramBatchStatus\": {\r",
									"                \"type\": \"string\",\r",
									"                \"enum\": [\"Active\", \"Inactive\"]\r",
									"            }\r",
									"        },\r",
									"        \"required\": [\r",
									"            \"userId\",\r",
									"            \"roleId\",\r",
									"            \"programId\",\r",
									"            \"batchId\",\r",
									"            \"userRoleProgramBatchStatus\"\r",
									"        ]\r",
									"    }\r",
									"};\r",
									"pm.test(\"Validate schema\", () => {\r",
									"    pm.response.to.have.jsonSchema(responseSchema);\r",
									"});\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/userRoleProgramBatchMap",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"userRoleProgramBatchMap"
							]
						}
					},
					"response": []
				},
				{
					"name": "GetUserRoleProgramBatch",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Should return 200 for valid request\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(200);\r",
									"    });\r",
									"     pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"OK\");\r",
									"    });\r",
									"\r",
									"//header validation\r",
									"pm.test(\"Header validation\", () => {\r",
									"    pm.response.to.have.header(\"Content-Type\");\r",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');\r",
									"});\r",
									"\r",
									"\r",
									"    pm.test(\"validate response body properties\", () => {\r",
									"        // Check the expected properties exist\r",
									"        pm.expect(pm.response.text()).to.include(\"userId\");\r",
									"        pm.expect(pm.response.text()).to.include(\"roleId\");\r",
									"        pm.expect(pm.response.text()).to.include(\"programId\");\r",
									"        pm.expect(pm.response.text()).to.include(\"batchId\");\r",
									"        pm.expect(pm.response.text()).to.include(\"userRoleProgramBatchStatus\");\r",
									"    });\r",
									"\r",
									"   \r",
									"\r",
									"    var responseSchema = {\r",
									"  \"type\": \"array\",\r",
									"  \"properties\": {\r",
									"    \"userId\": {\r",
									"      \"type\": \"string\"\r",
									"    },\r",
									"    \"roleId\": {\r",
									"      \"type\": \"string\"\r",
									"    },\r",
									"    \"programId\": {\r",
									"      \"type\": \"number\"\r",
									"    },\r",
									"    \"batchId\": {\r",
									"      \"type\": \"number\"\r",
									"    },\r",
									"    \"userRoleProgramBatchStatus\": {\r",
									"      \"type\": \"string\"\r",
									"    }\r",
									"  },\r",
									"  \"required\": [\r",
									"    \"userId\",\r",
									"    \"roleId\",\r",
									"    \"programId\",\r",
									"    \"batchId\",\r",
									"    \"userRoleProgramBatchStatus\"\r",
									"  ]\r",
									"};\r",
									"    pm.test(\"Validate schema\", () => {\r",
									"        pm.response.to.have.jsonSchema(responseSchema);\r",
									"    });\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/userRoleProgramBatchMap/{{ValidUserIdForGet}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"userRoleProgramBatchMap",
								"{{ValidUserIdForGet}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "GetAllUsersRoleProgramBatchWithNoAuth",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"\r",
									"    pm.test(\"Should return 401 for unauthorized request\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(401);\r",
									"    });\r",
									"     pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Unauthorized\");\r",
									"    });\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/userRoleProgramBatchMap",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"userRoleProgramBatchMap"
							]
						}
					},
					"response": []
				},
				{
					"name": "GetAllUsersRoleProgramBatchWithInvalidEndpoint",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"\r",
									"pm.test(\"Should return 404 for Not Found request\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(404);\r",
									"    });\r",
									" \r",
									" pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Not Found\");\r",
									"    });\r",
									"\r",
									"//header validation\r",
									"pm.test(\"Header validation\", () => {\r",
									"    pm.response.to.have.header(\"Content-Type\");\r",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('text/plain;charset=UTF-8');\r",
									"});\r",
									"\r",
									"\r",
									" pm.test(\"Error message Invalid Endpoint\", function () {\r",
									"    pm.expect(pm.response.text()).to.include('Invalid endpoint'); \r",
									"});\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/{{InvalidEndPointUserRoleProgramBatch}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"{{InvalidEndPointUserRoleProgramBatch}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "DeleteUserRoleProgramBatchWithValidId",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"const response = pm.response.json();\r",
									"pm.test(\"Should return 200 for valid request\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(200);\r",
									"    });\r",
									"     pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"OK\");\r",
									"    });\r",
									"//header validation\r",
									"pm.test(\"Header validation\", () => {\r",
									"    pm.response.to.have.header(\"Content-Type\");\r",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');\r",
									"});\r",
									"\r",
									"pm.test(\"Error message success truee\", function () {\r",
									"   pm.expect(response.success).to.eql(true);\r",
									"});\r",
									"pm.test(\"Validate response body with proper message\", function () {\r",
									"    const expectedMessage = `Deleted All Programs/Batches assigned to User ID`;\r",
									"\r",
									"    pm.expect(response.message).to.equal(expectedMessage);\r",
									"});\r",
									"\r",
									"\r",
									"\r",
									"if (pm.response.code === 200) {\r",
									"    pm.test(\"validate response body properties\", () => {\r",
									"        // Check the expected properties exist\r",
									"        pm.expect(pm.response.text()).to.include(\"message\");\r",
									"        pm.expect(pm.response.text()).to.include(\"success\");\r",
									"    });\r",
									"\r",
									"    pm.test(\"validate response body datatypes\", () => {\r",
									"        pm.expect(response).to.be.an(\"object\"); \r",
									"        pm.expect(response.message).to.be.a('string');\r",
									"        pm.expect(response.success).to.be.a('boolean'); \r",
									"    });\r",
									"\r",
									"    var responseSchema = {\r",
									"  \"type\": \"object\",\r",
									"  \"properties\": {\r",
									"    \"message\": {\r",
									"      \"type\": \"string\"\r",
									"    },\r",
									"    \"success\": {\r",
									"      \"type\": \"boolean\"\r",
									"    }\r",
									"  },\r",
									"  \"required\": [\r",
									"    \"message\",\r",
									"    \"success\"\r",
									"  ]\r",
									"};\r",
									"    pm.test(\"Validate schema\", () => {\r",
									"        pm.response.to.have.jsonSchema(responseSchema);\r",
									"    });\r",
									"}\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/userRoleProgramBatchMap/deleteAll/{{ValidUserIdForDelete}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"userRoleProgramBatchMap",
								"deleteAll",
								"{{ValidUserIdForDelete}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "GetUserRoleProgramBatchWithInvaildId",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"\r",
									"var response=pm.response.json();\r",
									"    pm.test(\"Should return 404 for Record Not Found\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(404);\r",
									"    });\r",
									"     pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Not Found\");\r",
									"    });\r",
									"//header validation\r",
									"pm.test(\"Header validation\", () => {\r",
									"    pm.response.to.have.header(\"Content-Type\");\r",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');\r",
									"    });\r",
									"\r",
									"    pm.test(\"Error message success false\", function () {\r",
									"   pm.expect(response.success).to.eql(false);\r",
									"});\r",
									"pm.test(\"Response contains invalid User id\", function () {\r",
									"\r",
									"    const responseText = pm.response.text();\r",
									"    const invalidUser = pm.collectionVariables.get(\"ValidUserIdForDelete\"); \r",
									"pm.expect(responseText).to.include(`Id : ${invalidUser}`);\r",
									"    \r",
									"});\r",
									"\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/userRoleProgramBatchMap/{{ValidUserIdForDelete}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"userRoleProgramBatchMap",
								"{{ValidUserIdForDelete}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "DeleteUserRoleProgramBatchMap",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Should return 404 for Not Found request\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(404);\r",
									"    });\r",
									"     pm.test(\"Status code name has string NotFound \", function () {\r",
									"        pm.response.to.have.status(\"Not Found\");\r",
									"    });\r",
									"\r",
									"//header validation\r",
									"pm.test(\"Header validation\", () => {\r",
									"    pm.response.to.have.header(\"Content-Type\");\r",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');\r",
									"});\r",
									"\r",
									" pm.test(\"Error message success false\", function () {\r",
									"   pm.expect(response.success).to.eql(false);\r",
									"});\r",
									"pm.test(\"Validate response body with invalid user id\", function () {\r",
									"    const expectedUserId = pm.collectionVariables.get(\"InvalidUserId\");\r",
									"    const expectedMessage = `UserRoleProgramBatchMap not found with id : ${expectedUserId} `;\r",
									"\r",
									"    pm.expect(response.message).to.equal(expectedMessage);\r",
									"});\r",
									"\r",
									"\r",
									"\r",
									"    pm.test(\"validate response body properties\", () => {\r",
									"        // Check the expected properties exist\r",
									"        pm.expect(pm.response.text()).to.include(\"message\");\r",
									"        pm.expect(pm.response.text()).to.include(\"success\");\r",
									"    });\r",
									"\r",
									"    pm.test(\"validate response body datatypes\", () => {\r",
									"        pm.expect(response).to.be.an(\"object\"); \r",
									"        pm.expect(response.message).to.be.a('string');\r",
									"        pm.expect(response.success).to.be.a('boolean'); \r",
									"    });\r",
									"\r",
									"    var responseSchema = {\r",
									"  \"type\": \"object\",\r",
									"  \"properties\": {\r",
									"    \"message\": {\r",
									"      \"type\": \"string\"\r",
									"    },\r",
									"    \"success\": {\r",
									"      \"type\": \"boolean\"\r",
									"    }\r",
									"  },\r",
									"  \"required\": [\r",
									"    \"message\",\r",
									"    \"success\"\r",
									"  ]\r",
									"};\r",
									"    pm.test(\"Validate schema\", () => {\r",
									"        pm.response.to.have.jsonSchema(responseSchema);\r",
									"    });\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/userRoleProgramBatchMap/deleteAll/{{InvalidUserId}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"userRoleProgramBatchMap",
								"deleteAll",
								"{{InvalidUserId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "GetUserRoleProgramBatchValidIdNoAuth",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"    pm.test(\"Should return 401 for unauthorized request\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(401);\r",
									"    });\r",
									"     pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Unauthorized\");\r",
									"    });\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/userRoleProgramBatchMap/{{ValidUserIdForGet}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"userRoleProgramBatchMap",
								"{{ValidUserIdForGet}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "DeleteUserRoleProgramBatchValidIdNoAuth",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"    pm.test(\"Should return 401 for unauthorized request\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(401);\r",
									"    });\r",
									"     pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Unauthorized\");\r",
									"    });\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/userRoleProgramBatchMap/deleteAll/{{ValidUserIdForDelete2}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"userRoleProgramBatchMap",
								"deleteAll",
								"{{ValidUserIdForDelete2}}"
							]
						}
					},
					"response": []
				}
			],
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"packages": {},
						"exec": [
							"/*const module = pm.iterationData.get('module').trim();\r",
							"\r",
							"if (module.toLowerCase() == 'program') {\r",
							"     pm.execution.skipRequest();       \r",
							"}*/"
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"packages": {},
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "ClassModule",
			"item": [
				{
					"name": "CreateNewClassScenarios",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"\r",
									"var responseBody = {};\r",
									"var testType = pm.iterationData.get(\"testTypePostClass\");\r",
									"var status_code=pm.iterationData.get(\"statuscodePostClass\");\r",
									"var scenarioName=pm.iterationData.get(\"scenarioNamePostClass\");\r",
									"// POST validations\r",
									"if (pm.iterationData.get(\"requestTypePostClass\") === \"POST\") {\r",
									"    // Positive and 201 validations\r",
									"    if ((testType === \"Positive\" && status_code === 201 && scenarioName === \"ValidClassData\")) {\r",
									"        responseBody = pm.response?.json();\r",
									"        // pm.collectionVariables.set(\"classId\", pm.responseBody.csId)\r",
									"        console.log('Executing 201 condition');\r",
									"        pm.test(\"Status code is 201 Created\", function () {\r",
									"            pm.response.to.have.status(201);\r",
									"        });\r",
									"        pm.test(\"Status code name has string\", function () {\r",
									"            pm.response.to.have.status(\"Created\");\r",
									"        });\r",
									"        pm.test(\"Content-Type is present\", function () {\r",
									"            pm.response.to.have.header(\"Content-Type\");\r",
									"        });\r",
									"        pm.test(\"Verify classTopic\", function () {\r",
									"            pm.expect(responseBody.classTopic).to.eql(pm.iterationData.get(\"classTopic\"));\r",
									"        });\r",
									"    }\r",
									"    // Negative and 401 validations\r",
									"    if ((testType === \"Negative\" && status_code === 401 && scenarioName === \"Unauthorized\")) {\r",
									"        pm.test(\"Status code is 401 Unauthorized\", function () {\r",
									"            pm.response.to.have.status(401);\r",
									"        });\r",
									"    }\r",
									"    // Negative and 404 validations - batch Id not found, staff not found\r",
									"    if ((testType === \"Negative\" && status_code === 404 && scenarioName === \"InvalidBatchId\")) {\r",
									"        responseBody = pm.response?.json();\r",
									"        pm.test(\"Status code is 404 Not found\", function () {\r",
									"            pm.response.to.have.status(404);\r",
									"        });\r",
									"        pm.test(\"Verify Batch Id not found\", function () {\r",
									"            pm.expect(responseBody.message).to.contains(pm.iterationData.get(\"messagePostClass\"));\r",
									"        });\r",
									"    }\r",
									"    if ((testType === \"Negative\" && status_code === 404 && scenarioName === \"InvalidStaffId\")) {\r",
									"        responseBody = pm.response?.json();\r",
									"        pm.test(\"Status code is 404 Not found\", function () {\r",
									"            pm.response.to.have.status(404);\r",
									"        });\r",
									"        pm.test(\"Verify Staff Id not found\", function () {\r",
									"            pm.expect(responseBody.message).to.contains(pm.iterationData.get(\"messagePostClass\"));\r",
									"        });\r",
									"    }\r",
									"    // Negative and Invalid endpoint validations\r",
									"    if ((testType === \"Negative\" && status_code === 404 && scenarioName === \"InvalidEndpoint\")) {\r",
									"        pm.test(\"Invalid endpoint\", function () {\r",
									"            pm.response.to.have.status(404);\r",
									"        });\r",
									"    }\r",
									"    // Negative and 400 validations - invalid date, count of classes with calender\r",
									"    if ((testType === \"Negative\" && status_code === 400 && scenarioName === \"CountOfClassesMismatch\")) {\r",
									"        responseBody = pm.response?.json();\r",
									"        pm.test(\"Classes Count and schedules mismatch validation\", function () {\r",
									"            pm.response.to.have.status(400);\r",
									"        });\r",
									"        pm.test(\"Verify class schedule error message\", function () {\r",
									"            pm.expect(responseBody.message).to.contains(pm.iterationData.get(\"messagePostClass\"));\r",
									"        });\r",
									"    }\r",
									"    if ((testType === \"Negative\" && status_code === 400 && scenarioName === \"PastClassDate\")) {\r",
									"        responseBody = pm.response?.json();\r",
									"        pm.test(\"Past class date validation\", function () {\r",
									"            pm.response.to.have.status(400);\r",
									"        });\r",
									"        pm.test(\"Verify past class error message\", function () {\r",
									"            pm.expect(responseBody.message).to.contains(pm.iterationData.get(\"messagePostClass\"));\r",
									"        });\r",
									"    }\r",
									"    if ((testType === \"Negative\" && status_code === 400 && scenarioName === \"MissingClassDate\")) {\r",
									"        responseBody = pm.response?.json();\r",
									"        pm.test(\"Missing class date validation\", function () {\r",
									"            pm.response.to.have.status(400);\r",
									"        });\r",
									"        pm.test(\"Verify missing class error message\", function () {\r",
									"            pm.expect(responseBody.message).to.contains(pm.iterationData.get(\"messagePostClass\"));\r",
									"        });\r",
									"    }\r",
									"    if ((testType === \"Negative\" && status_code === 400 && scenarioName === \"SameClassTopic\")) {\r",
									"        responseBody = pm.response?.json();\r",
									"        pm.test(\"Same Class Topic validation\", function () {\r",
									"            pm.response.to.have.status(400);\r",
									"        });\r",
									"        pm.test(\"Verify same class topic error message\", function () {\r",
									"            pm.expect(responseBody.message).to.contains(pm.iterationData.get(\"messagePostClass\"));\r",
									"        });\r",
									"    }\r",
									"  // POST validations End\r",
									"}\r",
									"// // GET Negative and 405 validations\r",
									"if (pm.iterationData.get(\"requestTypePostClass\") === \"GET\") {\r",
									"    if ((testType === \"Negative\" && status_code === 405 && scenarioName === \"MethodNotAllowed\")) {\r",
									"        pm.test(\"Method Not allowed\", function () {\r",
									"            pm.response.to.have.status(405);\r",
									"        });\r",
									"    }\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Retrieve the global access token\r",
									"var token = pm.globals.get(\"access_token\");\r",
									"// Retrieve the requiresAuth flag from the current iteration data\r",
									"var requiresAuth_check = pm.iterationData.get(\"requiresAuthPostClass\");\r",
									"var requestType = pm.iterationData.get(\"requestTypePostClass\");\r",
									"// Check if the current iteration requires authentication and the token exists\r",
									"if (requiresAuth_check === true && token) {\r",
									"    // Add the Authorization header for bearer token\r",
									"    pm.request.headers.upsert({\r",
									"        key: \"Authorization\",\r",
									"        value: \"Bearer \" + token\r",
									"    });\r",
									"    console.log(\"Authorization header set with token.\");\r",
									"} else {\r",
									"    // If no authentication is required, ensure the Authorization header is not set\r",
									"    console.log(\"Authorization header removed.\");\r",
									"    pm.request.headers.upsert({\r",
									"        key: \"Authorization\",\r",
									"        value: \"\"\r",
									"    });\r",
									"}\r",
									"// Function to handle \"null\" strings and convert them to actual null\r",
									"function handleNull(value) {\r",
									"    return value === \"null\" ? null : value;\r",
									"}\r",
									"// programId   16961\r",
									"// programName  postmanexplr\r",
									"// Retrieve and process global and iteration data for constructing the request body\r",
									"// var batchId = handleNull(pm.collectionVariables.get(\"batchId\"));\r",
									"// var batchName = handleNull(pm.collectionVariables.get(\"batchName\"));\r",
									"var batchId = handleNull(pm.iterationData.get(\"batchId\"));\r",
									"var batchName = handleNull(pm.iterationData.get(\"batchName_class\"));\r",
									"var classComments = handleNull(pm.iterationData.get(\"classComments\"));\r",
									"var classDate = handleNull(pm.iterationData.get(\"classDate\"));\r",
									"var classDescription = handleNull(pm.iterationData.get(\"classDescription\"));\r",
									"var classNo = handleNull(pm.iterationData.get(\"classNo\"));\r",
									"var classNotes = handleNull(pm.iterationData.get(\"classNotes\"));\r",
									"var classRecordingPath = handleNull(pm.iterationData.get(\"classRecordingPath\"));\r",
									"var classStaffId = handleNull(pm.iterationData.get(\"classStaffId\"));\r",
									"var classStatus = handleNull(pm.iterationData.get(\"classStatus\"));\r",
									"var classTopic = handleNull(pm.iterationData.get(\"classTopic\"));\r",
									"var classScheduledDatesString = handleNull(pm.iterationData.get(\"classScheduledDates\"));\r",
									"var classScheduledDates = classScheduledDatesString?.split(',') || []; // split returns array\r",
									"// Construct the request body\r",
									"var requestBody = {\r",
									"    \"batchId\": batchId,\r",
									"    \"batchName\": batchName,\r",
									"    \"classComments\": classComments,\r",
									"    \"classDate\": classDate,\r",
									"    \"classDescription\": classDescription,\r",
									"    \"classNo\": classNo,\r",
									"    \"classNotes\": classNotes,\r",
									"    \"classRecordingPath\":classRecordingPath,\r",
									"    \"classStaffId\": classStaffId,\r",
									"    \"classStatus\": classStatus,\r",
									"    \"classTopic\": classTopic,\r",
									"    \"classScheduledDates\": classScheduledDates\r",
									"};\r",
									"// Set the request body as a global variable for further use\r",
									"if (requestType === \"POST\") {\r",
									"    pm.globals.set(\"requestBody\", JSON.stringify(requestBody));\r",
									"    pm.request.method = \"POST\";\r",
									"} else if (requestType === \"GET\") {\r",
									"    console.log('setting GET method for request')\r",
									"    pm.request.method = \"GET\";\r",
									"}\r",
									"var baseUrl = pm.globals.get(\"baseurl\");\r",
									"var endpoint = pm.iterationData.get('endpointPostClass')\r",
									"if (endpoint === \"CreateClassSchedule\") {\r",
									"    pm.request.url = baseUrl + \"/\" + endpoint;\r",
									"    console.log(\"Using valid endpoint:\", baseUrl + \"/\" + endpoint, \"Scenario\", pm.iterationData.get('scenarioNamePostClass'));\r",
									"} else {\r",
									"    pm.request.url = baseUrl + \"/\" + endpoint;\r",
									"    console.log(\"Using invalid endpoint:\", baseUrl + \"/\" + endpoint);\r",
									"}\r",
									"\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "Authorization",
								"value": "Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJTZGV0QGdtYWlsLmNvbSIsImlhdCI6MTczMTA0NDY4MiwiZXhwIjoxNzMxMDczNDgyfQ.QDpSkxV6bXdP5g3OcUEwFh6tBoa7gccG_Z5o3EI8y1FJafobSfp8P_ZdLctQHfL2aql7FOJeVJ0_nFopTX7D6A"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{{requestBody}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "CreateClassSchedule",
							"host": [
								"CreateClassSchedule"
							]
						}
					},
					"response": []
				},
				{
					"name": "updateNewClass",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// var classId = pm.collectionVariables.get('ClassId');\r",
									"var classId = pm.iterationData.get('classId');\r",
									"console.log(\"Class Id---\",classId);\r",
									"\r",
									"var token = pm.globals.get(\"access_token\");\r",
									"var isValidEndpoint = pm.iterationData.get(\"EndPoint\");\r",
									"var requiresAuth_check = pm.iterationData.get(\"requiresAuth_classput\");\r",
									"var baseUrl = pm.globals.get(\"baseurl\");\r",
									"var validPath = \"/updateClass\";\r",
									"var invalidPath = \"/class\";\r",
									"if (isValidEndpoint === \"/updateClass\") {\r",
									"    pm.request.url = baseUrl + validPath +\"/\"+classId;\r",
									"    console.log(\"Using valid endpoint:\", pm.request.url);\r",
									"} else {\r",
									"    pm.request.url = baseUrl + validPath;\r",
									"    console.log(\"Using invalid endpoint:\",pm.request.url);\r",
									"}\r",
									"// var endpoint = pm.iterationData.get(\"EndPoint\");\r",
									"// var baseUrl = pm.globals.get(\"baseurl\");\r",
									"// // Construct the full URL\r",
									"// url = baseUrl + endpoint + '/' + classId;\r",
									"// pm.collectionVariables.set(\"updateClassUrl\", url);\r",
									"// console.log(\"URL : \" + url);\r",
									"var batchId = handleNull(pm.iterationData.get(\"batchId\"));\r",
									"var classNo = handleNull(pm.iterationData.get(\"classNo\"));\r",
									"var classDate = handleNull(pm.iterationData.get(\"classDate\"));\r",
									"var classTopic = handleNull(pm.iterationData.get(\"classTopic\"));\r",
									"var classStaffId = handleNull(pm.iterationData.get(\"classStaffId\"));\r",
									"var classDescription = handleNull(pm.iterationData.get(\"classDescription\"));\r",
									"var classComments = handleNull(pm.iterationData.get(\"classComments\"));\r",
									"var classNotes = handleNull(pm.iterationData.get(\"classNotes\"));\r",
									"var classRecordingPath = handleNull(pm.iterationData.get(\"classRecordingPath\"));\r",
									"var classScheduledDatesString = handleNull(pm.iterationData.get(\"classScheduledDates\"));\r",
									"var classScheduledDates = classScheduledDatesString?.split(',') || []; // split returns array\r",
									"var batchName = handleNull(pm.iterationData.get(\"batchName\"));\r",
									"\r",
									"var classRequestBody = {\r",
									"  \"batchId\": batchId,\r",
									"  \"classNo\": classNo,\r",
									"  \"classDate\": classDate,\r",
									"  \"classTopic\": classTopic,\r",
									"  \"classStaffId\": classStaffId,\r",
									"  \"classDescription\": classDescription,\r",
									"  \"classComments\": classComments,\r",
									"  \"classNotes\": classNotes,\r",
									"  \"classRecordingPath\": classRecordingPath,\r",
									"  \"batchName\":batchName,\r",
									"  \"classScheduledDates\":classScheduledDates\r",
									"  \r",
									"};\r",
									"pm.globals.set(\"classRequestBody\", JSON.stringify(classRequestBody));\r",
									"console.log(\"Request Body : \" + JSON.stringify(classRequestBody)); // Log the request body for debugging\r",
									"function handleNull(value) {\r",
									"  return value === null || value === undefined ? \"\" : value;\r",
									"}\r",
									"if (requiresAuth_check === true && token) {\r",
									"    // Add the Authorization header for bearer token\r",
									"    pm.request.headers.upsert({\r",
									"        key: \"Authorization\",\r",
									"        value: \"Bearer \" + token\r",
									"    });\r",
									"    console.log(\"Authorization header set with token.\");\r",
									"} else {\r",
									"    // If no authentication is required, ensure the Authorization header is not set\r",
									"    pm.request.headers.upsert({\r",
									"        key: \"Authorization\",\r",
									"        value: \"\"\r",
									"    });\r",
									"    console.log(\"Authorization header removed.\");\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = {};\r",
									"var testType = pm.iterationData.get(\"testTypePutClass\");\r",
									"var status_code=pm.iterationData.get(\"statuscodePutClass\");\r",
									"var scenarioName=pm.iterationData.get(\"scenarioNamePutClass\");\r",
									"var requestType = pm.iterationData.get(\"requestTypePutClass\")\r",
									"// POST validations\r",
									"if (requestType === \"PUT\") {\r",
									"    // Positive and 200 validations\r",
									"    if (testType === \"Positive\" && status_code === 200 && \r",
									"        (scenarioName === \"ValidClassUpdate\" || scenarioName === \"ValidClassUpdateWithMoreClasses\")) {\r",
									"        responseBody = pm.response?.json();\r",
									"        // pm.collectionVariables.set(\"classId\", pm.responseBody.csId)\r",
									"        console.log('Executing 200 condition');\r",
									"        pm.test(\"Status code is 200 Ok\", function () {\r",
									"            pm.response.to.have.status(200);\r",
									"        });\r",
									"        pm.test(\"Verify updated class\", function () {\r",
									"            pm.expect(responseBody.csId).to.eql(pm.iterationData.get(\"classId\"));\r",
									"        });\r",
									"    }\r",
									"\r",
									"     // Negative and 401 validations\r",
									"    if ((testType === \"Negative\" && status_code === 401 && scenarioName === \"Unauthorized\")) {\r",
									"        pm.test(\"Status code is 401 Unauthorized\", function () {\r",
									"            pm.response.to.have.status(401);\r",
									"        });\r",
									"    }\r",
									"    // Negative and Invalid endpoint validations\r",
									"    if ((testType === \"Negative\" && status_code === 404 && scenarioName === \"InvalidEndpoint\")) {\r",
									"        pm.test(\"Invalid endpoint\", function () {\r",
									"            pm.response.to.have.status(404);\r",
									"        });\r",
									"    }\r",
									"  // PUT validations End\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{classRequestBody}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseurl}}/updateClass",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"updateClass"
							]
						}
					},
					"response": []
				},
				{
					"name": "GetClassRecordings",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Should return 200 for valid request\", function () {\r",
									"    pm.expect(pm.response.code).to.eql(200);\r",
									"});\r",
									"pm.test(\"Status code name has string\", function () {\r",
									"    pm.response.to.have.status(\"OK\");\r",
									"});\r",
									"\r",
									"//header validation\r",
									"pm.test(\"Header validation\", () => {\r",
									"    pm.response.to.have.header(\"Content-Type\");\r",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');\r",
									"});\r",
									"\r",
									"pm.test(\"validate response body properties\", () => {\r",
									"    // Check the expected properties exist\r",
									"    pm.expect(pm.response.text()).to.include(\"csId\");\r",
									"    pm.expect(pm.response.text()).to.include(\"classRecordingPath\");\r",
									"});\r",
									"\r",
									"pm.collectionVariables.set('ValidClassId', response[0].csId);\r",
									"\r",
									"pm.test(\"validate response body datatypes\", () => {\r",
									"    pm.expect(response).to.be.an(\"array\"); \r",
									"\r",
									"    response.forEach((item) => {\r",
									"        pm.expect(item.csId).to.be.a('number').and.to.not.be.null;\r",
									"         pm.expect(item.classRecordingPath).to.satisfy(classRecordingPath => typeof classRecordingPath === \"string\" || classRecordingPath === null, \"classRecordingPath should be a string or null\");\r",
									"        if(item.classRecordingPath === null)\r",
									"            pm.collectionVariables.set('InvalidClassIdRecordings',item.csId);\r",
									"        else\r",
									"            pm.collectionVariables.set('ValidClassIdRecordings',item.csId);\r",
									"    });\r",
									"});\r",
									"\r",
									"var responseSchema = {\r",
									"    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\r",
									"    \"type\": \"array\", \r",
									"    \"items\": {\r",
									"        \"type\": \"object\",\r",
									"        \"properties\": {\r",
									"            \"csId\": {\r",
									"                \"type\": \"number\"\r",
									"            },\r",
									"            \"classRecordingPath\": {\r",
									"                \"type\": [\"string\",\"null\"]\r",
									"            }\r",
									"        },\r",
									"        \"required\": [\r",
									"            \"csId\",\r",
									"            \"classRecordingPath\"\r",
									"        ]\r",
									"    }\r",
									"};\r",
									"pm.test(\"Validate schema\", () => {\r",
									"    pm.response.to.have.jsonSchema(responseSchema);\r",
									"});\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/classrecordings",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"classrecordings"
							]
						}
					},
					"response": []
				},
				{
					"name": "GetRecordingsDownloadInvalidId",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"\r",
									"var response=pm.response.json();\r",
									"    pm.test(\"Should return 404 for Record Not Found\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(404);\r",
									"    });\r",
									"     pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Not Found\");\r",
									"    });\r",
									"//header validation\r",
									"pm.test(\"Header validation\", () => {\r",
									"    pm.response.to.have.header(\"Content-Type\");\r",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');\r",
									"    });\r",
									"\r",
									"    pm.test(\"Error message success false\", function () {\r",
									"   pm.expect(response.success).to.eql(false);\r",
									"});\r",
									"pm.test(\"Response contains invalid class id\", function () {\r",
									"\r",
									"    const responseText = pm.response.text();\r",
									"    const invalidClass = pm.collectionVariables.get(\"InvalidClassId\"); \r",
									"pm.expect(responseText).to.include(`Class not found with Id : ${invalidClass} `);\r",
									"    \r",
									"});\r",
									"\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/download/{{InvalidClassId}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"download",
								"{{InvalidClassId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "GetRecordingsDownloadClassId",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Should return 200 for valid request\", function () {\r",
									"    pm.expect(pm.response.code).to.eql(200);\r",
									"});\r",
									"pm.test(\"Status code name has string\", function () {\r",
									"    pm.response.to.have.status(\"OK\");\r",
									"});\r",
									"\r",
									"//header validation\r",
									"pm.test(\"Header validation\", () => {\r",
									"    pm.response.to.have.header(\"Content-Type\");\r",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');\r",
									"});\r",
									"\r",
									"pm.test(\"validate response body properties\", () => {\r",
									"    // Check the expected properties exist\r",
									"    pm.expect(response).to.include.keys(\"csId\", \"classRecordingPath\");\r",
									"    pm.expect(response.classRecordingPath).to.satisfy(classRecordingPath => typeof classRecordingPath === \"string\" || classRecordingPath === null, \"classRecordingPath should be a string or null\");\r",
									"});\r",
									"\r",
									"pm.collectionVariables.set('ValidClassId', response.csId);\r",
									"\r",
									"pm.test(\"validate response body datatypes\", () => {\r",
									"    pm.expect(response).to.be.an(\"object\"); \r",
									"    pm.expect(response.csId).to.be.a('number').and.to.not.be.null;\r",
									"    pm.expect(response.classRecordingPath).to.be.a('string');\r",
									"});\r",
									"\r",
									"var responseSchema = {\r",
									"    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\r",
									"    \"type\": \"object\", \r",
									"    \"properties\": {\r",
									"        \"csId\": {\r",
									"            \"type\": \"number\"\r",
									"        },\r",
									"        \"classRecordingPath\": {\r",
									"            \"type\": \"string\"\r",
									"        }\r",
									"    },\r",
									"    \"required\": [\r",
									"        \"csId\",\r",
									"        \"classRecordingPath\"\r",
									"    ]\r",
									"};\r",
									"pm.test(\"Validate schema\", () => {\r",
									"    pm.response.to.have.jsonSchema(responseSchema);\r",
									"});\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/download/{{ValidClassIdRecordings}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"download",
								"{{ValidClassIdRecordings}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "GetClassRecordingsVaildClassId",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Should return 200 for valid request\", function () {\r",
									"    pm.expect(pm.response.code).to.eql(200);\r",
									"});\r",
									"pm.test(\"Status code name has string\", function () {\r",
									"    pm.response.to.have.status(\"OK\");\r",
									"});\r",
									"\r",
									"//header validation\r",
									"pm.test(\"Header validation\", () => {\r",
									"    pm.response.to.have.header(\"Content-Type\");\r",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');\r",
									"});\r",
									"\r",
									"pm.test(\"validate response body properties\", () => {\r",
									"    // Check the expected properties exist\r",
									"    pm.expect(pm.response.text()).to.include(\"csId\");\r",
									"    pm.expect(pm.response.text()).to.include(\"classRecordingPath\");\r",
									"});\r",
									"\r",
									"\r",
									"pm.test(\"validate response body datatypes\", () => {\r",
									"    pm.expect(response).to.be.an(\"object\"); \r",
									"    pm.expect(response.csId).to.be.a('number').and.to.not.be.null;\r",
									"    pm.expect(response.classRecordingPath).to.satisfy(classRecordingPath => typeof classRecordingPath === \"string\" || classRecordingPath === null, \"classRecordingPath should be a string or null\");\r",
									"});\r",
									"\r",
									"var responseSchema = {\r",
									"    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\r",
									"    \"type\": \"object\", \r",
									"    \"properties\": {\r",
									"        \"csId\": {\r",
									"            \"type\": \"number\"\r",
									"        },\r",
									"        \"classRecordingPath\": {\r",
									"            \"type\": \"string\"\r",
									"        }\r",
									"    },\r",
									"    \"required\": [\r",
									"        \"csId\",\r",
									"        \"classRecordingPath\"\r",
									"    ]\r",
									"};\r",
									"pm.test(\"Validate schema\", () => {\r",
									"    pm.response.to.have.jsonSchema(responseSchema);\r",
									"});\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/classRecordings/{{ValidClassIdRecordings}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"classRecordings",
								"{{ValidClassIdRecordings}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "GetClassRecordingsInvalidClassId",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var response = pm.response.json();\r",
									"\r",
									"pm.test(\"Should return 404 for Record Not Found\", function () {\r",
									"    pm.expect(pm.response.code).to.eql(404);\r",
									"});\r",
									"\r",
									"pm.test(\"Status code name has string\", function () {\r",
									"    pm.response.to.have.status(\"Not Found\");\r",
									"});\r",
									"\r",
									"// header validation\r",
									"pm.test(\"Header validation\", () => {\r",
									"    pm.response.to.have.header(\"Content-Type\");\r",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');\r",
									"});\r",
									"\r",
									"pm.test(\"Error message success false\", function () {\r",
									"    pm.expect(response.success).to.eql(false);\r",
									"});\r",
									"\r",
									"pm.test(\"Response contains invalid class id\", function () {\r",
									"    const invalidClass = pm.collectionVariables.get(\"InvalidClassId\");\r",
									"    pm.expect(response.message).to.eql(`Class not found with Id : ${invalidClass} `);\r",
									"});\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/classRecordings/{{InvalidClassId}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"classRecordings",
								"{{InvalidClassId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "GetAllClasses",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// var response = pm.response.json();\r",
									"// pm.test(\"Should return 200 for unauthorized request\", function () {\r",
									"//     pm.expect(pm.response.code).to.eql(200);\r",
									"// });\r",
									"\r",
									"// pm.test(\"Status code name has string\", function () {\r",
									"//     pm.response.to.have.status(\"OK\");\r",
									"// });\r",
									"\r",
									"// //header validation\r",
									"// pm.test(\"Header validation\", () => {\r",
									"//     pm.response.to.have.header(\"Content-Type\");\r",
									"//     pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');\r",
									"// });\r",
									"\r",
									"// if (pm.response.code === 200) {\r",
									"//     pm.test(\"validate response body properties\", () => {\r",
									"//         // Check the expected properties exist\r",
									"//         pm.expect(pm.response.text()).to.include(\"csId\");\r",
									"//         pm.expect(pm.response.text()).to.include(\"batchId\");\r",
									"//         pm.expect(pm.response.text()).to.include(\"classNo\");\r",
									"//         pm.expect(pm.response.text()).to.include(\"classDate\");\r",
									"//         pm.expect(pm.response.text()).to.include(\"classTopic\");\r",
									"//         pm.expect(pm.response.text()).to.include(\"classStatus\");\r",
									"//         pm.expect(pm.response.text()).to.include(\"classStaffId\");\r",
									"//         pm.expect(pm.response.text()).to.include(\"classDescription\");\r",
									"//         pm.expect(pm.response.text()).to.include(\"classComments\");\r",
									"//         pm.expect(pm.response.text()).to.include(\"classNotes\");\r",
									"//         pm.expect(pm.response.text()).to.include(\"classRecordingPath\");\r",
									"//         pm.expect(pm.response.text()).to.include(\"batchName\");\r",
									"//         pm.expect(pm.response.text()).to.include(\"classScheduledDates\");\r",
									"//     });\r",
									"//     pm.collectionVariables.set('ValidBatchIdClass',response[0].batchId);\r",
									"//     pm.collectionVariables.set('ValidClassId', response[0].csId);\r",
									"//      pm.test(\"validate response body datatypes\", () => {\r",
									"//         pm.expect(response).to.be.an(\"array\");\r",
									"\r",
									"//         response.forEach((item) => {\r",
									"//             pm.expect(item.csId).to.be.a(\"number\").and.to.be.not.null;\r",
									"//             pm.expect(item.batchId).to.be.a(\"number\").and.to.be.not.null;\r",
									"//             pm.expect(item.classNo).to.be.a(\"number\").and.to.be.not.null;\r",
									"//             pm.expect(item.classDate).to.be.a(\"string\").and.to.be.not.null;\r",
									"//             pm.expect(item.classTopic).to.be.a(\"string\").and.to.be.not.null;\r",
									"//             pm.expect(item.classStatus).to.be.a(\"string\").and.to.be.not.null;\r",
									"//             pm.expect(item.classStaffId).to.be.a(\"string\").and.to.be.not.null;\r",
									"//             pm.expect(item.classDescription).to.satisfy(classDescription => typeof classDescription === \"string\" || classDescription === null, \"classDescription should be a string or null\");\r",
									"//             pm.expect(item.classComments).to.satisfy(classComments => typeof classComments === \"string\" || classComments === null, \"classComments should be a string or null\");\r",
									"//             pm.expect(item.classNotes).to.satisfy(classNotes => typeof classNotes === \"string\" || classNotes === null, \"classNotes should be a string or null\");\r",
									"//             pm.expect(item.classRecordingPath).to.satisfy(classRecordingPath => typeof classRecordingPath === \"string\" || classRecordingPath === null, \"classRecordingPath should be a string or null\");\r",
									"//             pm.expect(item.batchName).to.satisfy(batchName => typeof batchName === \"string\" || batchName === null, \"batchName should be a string or null\");\r",
									"//             pm.expect(item.classScheduledDates).to.satisfy(function (value) {\r",
									"//                 return Array.isArray(value) || value === null;\r",
									"//             }, \"classScheduledDates should be an array or null\");\r",
									"//         });\r",
									"//     });\r",
									"//     var responseSchema = {\r",
									"//         \"type\": \"array\",\r",
									"//         \"items\": {\r",
									"//             \"type\": \"object\",\r",
									"//             \"properties\": {\r",
									"//                 \"csId\": { \"type\": \"number\" },\r",
									"//                 \"batchId\": { \"type\": \"number\" },\r",
									"//                 \"classNo\": { \"type\": \"number\" },\r",
									"//                 \"classDate\": { \"type\": \"string\" },\r",
									"//                 \"classTopic\": { \"type\": \"string\" },\r",
									"//                 \"classStatus\": { \"type\": \"string\" },\r",
									"//                 \"classStaffId\": { \"type\": \"string\" },\r",
									"//                 \"classDescription\": { \"type\": [\"string\", \"null\"] },\r",
									"//                 \"classComments\": { \"type\": [\"string\", \"null\"] },\r",
									"//                 \"classNotes\": { \"type\": [\"string\", \"null\"] },\r",
									"//                 \"classRecordingPath\": { \"type\": [\"string\", \"null\"] },\r",
									"//                 \"batchName\": { \"type\": [\"string\", \"null\"] },\r",
									"//                 \"classScheduledDates\": {\r",
									"//                     \"type\": [\"array\", \"null\"],\r",
									"//                     \"items\": { \"type\": \"string\" }\r",
									"//                 }\r",
									"//             },\r",
									"//             \"required\": [\r",
									"//                 \"csId\",\r",
									"//                 \"batchId\",\r",
									"//                 \"classNo\",\r",
									"//                 \"classDate\",\r",
									"//                 \"classTopic\",\r",
									"//                 \"classStatus\",\r",
									"//                 \"classStaffId\"\r",
									"//             ]\r",
									"//         }\r",
									"//     };\r",
									"//     pm.test(\"Validate schema\", () => {\r",
									"//         pm.response.to.have.jsonSchema(responseSchema);\r",
									"//     });\r",
									"// }\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/allClasses",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"allClasses"
							]
						}
					},
					"response": []
				},
				{
					"name": "GetAllClassesInvalidEndpoint",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Should return 404 for not found\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(404);\r",
									"    });\r",
									" \r",
									" pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Not Found\");\r",
									"    });\r",
									"\r",
									"    //header validation\r",
									"pm.test(\"Header validation\", () => {\r",
									"    pm.response.to.have.header(\"Content-Type\");\r",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('text/plain');\r",
									"});\r",
									"\r",
									" pm.test(\"Error message Invalid Endpoint\", function () {\r",
									"    pm.expect(responseBody).to.include(\"Invalid endpoint\"); \r",
									"});\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/allClass",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"allClass"
							]
						}
					},
					"response": []
				},
				{
					"name": "GetAllClassesWithSearchString",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var response = pm.response.json();\r",
									"pm.test(\"Should return 200 for unauthorized request\", function () {\r",
									"    pm.expect(pm.response.code).to.eql(200);\r",
									"});\r",
									"\r",
									"pm.test(\"Status code name has string\", function () {\r",
									"    pm.response.to.have.status(\"OK\");\r",
									"});\r",
									"\r",
									"//header validation\r",
									"pm.test(\"Header validation\", () => {\r",
									"    pm.response.to.have.header(\"Content-Type\");\r",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');\r",
									"});\r",
									"\r",
									"if (pm.response.code === 200) {\r",
									"    pm.test(\"validate response body properties\", () => {\r",
									"        // Check the expected properties exist\r",
									"        pm.expect(pm.response.text()).to.include(\"csId\");\r",
									"        pm.expect(pm.response.text()).to.include(\"batchId\");\r",
									"        pm.expect(pm.response.text()).to.include(\"classNo\");\r",
									"        pm.expect(pm.response.text()).to.include(\"classDate\");\r",
									"        pm.expect(pm.response.text()).to.include(\"classTopic\");\r",
									"        pm.expect(pm.response.text()).to.include(\"classStatus\");\r",
									"        pm.expect(pm.response.text()).to.include(\"classStaffId\");\r",
									"        pm.expect(pm.response.text()).to.include(\"classDescription\");\r",
									"        pm.expect(pm.response.text()).to.include(\"classComments\");\r",
									"        pm.expect(pm.response.text()).to.include(\"classNotes\");\r",
									"        pm.expect(pm.response.text()).to.include(\"classRecordingPath\");\r",
									"        pm.expect(pm.response.text()).to.include(\"batchName\");\r",
									"        pm.expect(pm.response.text()).to.include(\"classScheduledDates\");\r",
									"    });\r",
									"    pm.collectionVariables.set('ValidBatchIdClass',response[0].batchId);\r",
									"    pm.collectionVariables.set('ValidClassId', response[0].csId);\r",
									"\r",
									"\r",
									"   pm.test(\"validate response body datatypes\", () => {\r",
									"    pm.expect(response).to.be.an(\"array\");\r",
									"\r",
									"    response.forEach((item) => {\r",
									"        pm.expect(item.csId).to.be.a(\"number\").and.to.be.not.null;\r",
									"        pm.expect(item.batchId).to.be.a(\"number\").and.to.be.not.null;\r",
									"        pm.expect(item.classNo).to.be.a(\"number\").and.to.be.not.null;\r",
									"        pm.expect(item.classDate).to.be.a(\"string\").and.to.be.not.null;\r",
									"         pm.expect(item.classTopic).to.satisfy(classTopic => typeof classTopic === \"string\" || classTopic === null, \"classTopic should be a string or null\");\r",
									"        pm.expect(item.classStatus).to.satisfy(classStatus => typeof classStatus === \"string\" || classStatus === null, \"classStatus should be a string or null\");\r",
									"        pm.expect(item.classStaffId).to.be.a(\"string\").and.to.be.not.null;\r",
									"\r",
									"        pm.expect(item.classDescription).to.satisfy(classDescription => typeof classDescription === \"string\" || classDescription === null, \"classDescription should be a string or null\");\r",
									"        pm.expect(item.classComments).to.satisfy(classComments => typeof classComments === \"string\" || classComments === null, \"classComments should be a string or null\");\r",
									"        pm.expect(item.classNotes).to.satisfy(classNotes => typeof classNotes === \"string\" || classNotes === null, \"classNotes should be a string or null\");\r",
									"        pm.expect(item.classRecordingPath).to.satisfy(classRecordingPath => typeof classRecordingPath === \"string\" || classRecordingPath === null, \"classRecordingPath should be a string or null\");\r",
									"\r",
									"        pm.expect(item.batchName).to.satisfy(batchName => typeof batchName === \"string\" || batchName === null, \"batchName should be a string or null\");\r",
									"\r",
									"        // Correct the validation for classScheduledDates to be an array or null\r",
									"        pm.expect(item.classScheduledDates).to.satisfy(classScheduledDates => Array.isArray(classScheduledDates) || classScheduledDates === null, \"classScheduledDates should be an array or null\");\r",
									"    });\r",
									"});\r",
									"\r",
									"\r",
									"   const schema = {\r",
									"    \"type\": \"array\",\r",
									"    \"items\": {\r",
									"        \"type\": \"object\",\r",
									"        \"properties\": {\r",
									"            \"csId\": { \"type\": \"integer\" },\r",
									"            \"batchId\": { \"type\": \"integer\" },\r",
									"            \"classNo\": { \"type\": \"integer\" },\r",
									"            \"classDate\": { \"type\": \"string\", \"format\": \"date-time\" },\r",
									"            \"classTopic\": { \"type\": [\"string\", \"null\"] },\r",
									"            \"classStatus\": { \"type\": [\"string\", \"null\"] },\r",
									"            \"classStaffId\": { \"type\": \"string\" },\r",
									"             \"classDescription\": { \"type\": [\"string\", \"null\"] },  \r",
									"            \"classComments\": { \"type\": [\"string\", \"null\"] }, \r",
									"            \"classNotes\": { \"type\": [\"string\", \"null\"] },  // Allows null if missing\r",
									"            \"classRecordingPath\": { \"type\": [\"string\", \"null\"] },\r",
									"            \"batchName\": { \"type\": \"string\" },\r",
									"            \"classScheduledDates\": {\r",
									"                \"type\": [\"array\", \"null\"],\r",
									"                \"items\": { \"type\": \"string\", \"format\": \"date-time\" }\r",
									"            }\r",
									"        },\r",
									"        \"required\": [\r",
									"            \"csId\",\r",
									"            \"batchId\",\r",
									"            \"classNo\",\r",
									"            \"classDate\",\r",
									"            \"classTopic\",\r",
									"            \"classStatus\",\r",
									"            \"classStaffId\",\r",
									"            \"classDescription\",\r",
									"            \"classComments\",\r",
									"            \"batchName\"\r",
									"        ]\r",
									"    }\r",
									"};\r",
									"\r",
									"// Validate the response\r",
									"pm.test(\"Response schema is valid\", function () {\r",
									"    pm.response.to.have.jsonSchema(schema);\r",
									"});\r",
									"\r",
									"}\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/allClasses?csId={{csId}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"allClasses"
							],
							"query": [
								{
									"key": "csId",
									"value": "{{csId}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "GetAllClassesWithoutAuth",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"\r",
									"    pm.test(\"Should return 401 for unauthorized request\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(401);\r",
									"    });\r",
									"     pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Unauthorized\");\r",
									"    });\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/allClasses",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"allClasses"
							]
						}
					},
					"response": []
				},
				{
					"name": "GetClassesByClassTopic",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var response = pm.response.json();\r",
									"\r",
									"pm.test(\"Should return 200 for OK request\", function () {\r",
									"    pm.expect(pm.response.code).to.eql(200);\r",
									"});\r",
									"\r",
									"pm.test(\"Status code name has string\", function () {\r",
									"    pm.response.to.have.status(\"OK\");\r",
									"});\r",
									"\r",
									"//header validation\r",
									"pm.test(\"Header validation\", () => {\r",
									"    pm.response.to.have.header(\"Content-Type\");\r",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');\r",
									"});\r",
									"\r",
									"if (pm.response.code === 200) {\r",
									"    pm.test(\"validate response body properties\", () => {\r",
									"        // Check the expected properties exist\r",
									"        pm.expect(pm.response.text()).to.include(\"csId\");\r",
									"        pm.expect(pm.response.text()).to.include(\"batchId\");\r",
									"        pm.expect(pm.response.text()).to.include(\"classNo\");\r",
									"        pm.expect(pm.response.text()).to.include(\"classDate\");\r",
									"        pm.expect(pm.response.text()).to.include(\"classTopic\");\r",
									"        pm.expect(pm.response.text()).to.include(\"classStatus\");\r",
									"        pm.expect(pm.response.text()).to.include(\"classStaffId\");\r",
									"        pm.expect(pm.response.text()).to.include(\"classDescription\");\r",
									"        pm.expect(pm.response.text()).to.include(\"classComments\");\r",
									"        pm.expect(pm.response.text()).to.include(\"classNotes\");\r",
									"        pm.expect(pm.response.text()).to.include(\"classRecordingPath\");\r",
									"        pm.expect(pm.response.text()).to.include(\"batchName\");\r",
									"        pm.expect(pm.response.text()).to.include(\"classScheduledDates\");\r",
									"    });\r",
									"    pm.collectionVariables.set('ValidBatchIdClass',response[0].batchId);\r",
									"    pm.collectionVariables.set('ValidClassId', response[0].csId);\r",
									"    pm.test(\"validate response body datatypes\", () => {\r",
									"        pm.expect(response).to.be.an(\"array\");\r",
									"\r",
									"        response.forEach((item) => {\r",
									"            pm.expect(item.csId).to.be.a(\"number\").and.to.be.not.null;\r",
									"            pm.expect(item.batchId).to.be.a(\"number\").and.to.be.not.null;\r",
									"            pm.expect(item.classNo).to.be.a(\"number\").and.to.be.not.null;\r",
									"            pm.expect(item.classDate).to.be.a(\"string\").and.to.be.not.null;\r",
									"            pm.expect(item.classTopic).to.be.a(\"string\").and.to.be.not.null;\r",
									"            pm.expect(item.classStatus).to.be.a(\"string\").and.to.be.not.null;\r",
									"            pm.expect(item.classStaffId).to.be.a(\"string\").and.to.be.not.null;\r",
									"            pm.expect(item.classDescription).to.satisfy(classDescription => typeof classDescription === \"string\" || classDescription === null, \"classDescription should be a string or null\");\r",
									"            pm.expect(item.classComments).to.satisfy(classComments => typeof classComments === \"string\" || classComments === null, \"classComments should be a string or null\");\r",
									"            pm.expect(item.classNotes).to.satisfy(classNotes => typeof classNotes === \"string\" || classNotes === null, \"classNotes should be a string or null\");\r",
									"            pm.expect(item.classRecordingPath).to.satisfy(classRecordingPath => typeof classRecordingPath === \"string\" || classRecordingPath === null, \"classRecordingPath should be a string or null\");\r",
									"            pm.expect(item.batchName).to.satisfy(batchName => typeof batchName === \"string\" || batchName === null, \"batchName should be a string or null\");\r",
									"            pm.expect(item.classScheduledDates).to.satisfy(function (value) {\r",
									"                return Array.isArray(value) || value === null;\r",
									"            }, \"classScheduledDates should be an array or null\");\r",
									"        });\r",
									"    });\r",
									"    var responseSchema = {\r",
									"        \"type\": \"array\",\r",
									"        \"items\": {\r",
									"            \"type\": \"object\",\r",
									"            \"properties\": {\r",
									"                \"csId\": { \"type\": \"number\" },\r",
									"                \"batchId\": { \"type\": \"number\" },\r",
									"                \"classNo\": { \"type\": \"number\" },\r",
									"                \"classDate\": { \"type\": \"string\" },\r",
									"                \"classTopic\": { \"type\": \"string\" },\r",
									"                \"classStatus\": { \"type\": \"string\" },\r",
									"                \"classStaffId\": { \"type\": \"string\" },\r",
									"                \"classDescription\": { \"type\": [\"string\", \"null\"] },\r",
									"                \"classComments\": { \"type\": [\"string\", \"null\"] },\r",
									"                \"classNotes\": { \"type\": [\"string\", \"null\"] },\r",
									"                \"classRecordingPath\": { \"type\": [\"string\", \"null\"] },\r",
									"                \"batchName\": { \"type\": [\"string\", \"null\"] },\r",
									"                \"classScheduledDates\": {\r",
									"                    \"type\": [\"array\", \"null\"],\r",
									"                    \"items\": { \"type\": \"string\" }\r",
									"                }\r",
									"            },\r",
									"            \"required\": [\r",
									"                \"csId\",\r",
									"                \"batchId\",\r",
									"                \"classNo\",\r",
									"                \"classDate\",\r",
									"                \"classTopic\",\r",
									"                \"classStatus\",\r",
									"                \"classStaffId\"\r",
									"            ]\r",
									"        }\r",
									"    };\r",
									"    pm.test(\"Validate schema\", () => {\r",
									"        pm.response.to.have.jsonSchema(responseSchema);\r",
									"    });\r",
									"}\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/classes/{{classTopic}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"classes",
								"{{classTopic}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "GetClassesByClassTopicNoAuth",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"\r",
									"    pm.test(\"Should return 401 for unauthorized request\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(401);\r",
									"    });\r",
									"     pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Unauthorized\");\r",
									"    });\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/classes/{{classTopic}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"classes",
								"{{classTopic}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "GetAllClassesByStaffId",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var response = pm.response.json();\r",
									"pm.test(\"Should return 200 for OK request\", function () {\r",
									"    pm.expect(pm.response.code).to.eql(200);\r",
									"});\r",
									"\r",
									"pm.test(\"Status code name has string\", function () {\r",
									"    pm.response.to.have.status(\"OK\");\r",
									"});\r",
									"\r",
									"//header validation\r",
									"pm.test(\"Header validation\", () => {\r",
									"    pm.response.to.have.header(\"Content-Type\");\r",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');\r",
									"});\r",
									"\r",
									"if (pm.response.code === 200) {\r",
									"    pm.test(\"validate response body properties\", () => {\r",
									"        // Check the expected properties exist\r",
									"        pm.expect(pm.response.text()).to.include(\"csId\");\r",
									"        pm.expect(pm.response.text()).to.include(\"batchId\");\r",
									"        pm.expect(pm.response.text()).to.include(\"classNo\");\r",
									"        pm.expect(pm.response.text()).to.include(\"classDate\");\r",
									"        pm.expect(pm.response.text()).to.include(\"classTopic\");\r",
									"        pm.expect(pm.response.text()).to.include(\"classStatus\");\r",
									"        pm.expect(pm.response.text()).to.include(\"classStaffId\");\r",
									"        pm.expect(pm.response.text()).to.include(\"classDescription\");\r",
									"        pm.expect(pm.response.text()).to.include(\"classComments\");\r",
									"        pm.expect(pm.response.text()).to.include(\"classNotes\");\r",
									"        pm.expect(pm.response.text()).to.include(\"classRecordingPath\");\r",
									"        pm.expect(pm.response.text()).to.include(\"batchName\");\r",
									"        pm.expect(pm.response.text()).to.include(\"classScheduledDates\");\r",
									"    });\r",
									"    pm.collectionVariables.set('ValidBatchIdClass',response[0].batchId);\r",
									"    pm.collectionVariables.set('ValidClassId', response[0].csId);\r",
									"\r",
									"\r",
									"   pm.test(\"validate response body datatypes\", () => {\r",
									"    pm.expect(response).to.be.an(\"array\");\r",
									"\r",
									"    response.forEach((item) => {\r",
									"        pm.expect(item.csId).to.be.a(\"number\").and.to.be.not.null;\r",
									"        pm.expect(item.batchId).to.be.a(\"number\").and.to.be.not.null;\r",
									"        pm.expect(item.classNo).to.be.a(\"number\").and.to.be.not.null;\r",
									"        pm.expect(item.classDate).to.be.a(\"string\").and.to.be.not.null;\r",
									"        pm.expect(item.classTopic).to.be.a(\"string\").and.to.be.not.null;\r",
									"        pm.expect(item.classStatus).to.satisfy(classStatus => typeof classStatus === \"string\" || classStatus === null, \"classStatus should be a string or null\");\r",
									"        pm.expect(item.classStaffId).to.be.a(\"string\").and.to.be.not.null;\r",
									"\r",
									"        pm.expect(item.classDescription).to.satisfy(classDescription => typeof classDescription === \"string\" || classDescription === null, \"classDescription should be a string or null\");\r",
									"        pm.expect(item.classComments).to.satisfy(classComments => typeof classComments === \"string\" || classComments === null, \"classComments should be a string or null\");\r",
									"        pm.expect(item.classNotes).to.satisfy(classNotes => typeof classNotes === \"string\" || classNotes === null, \"classNotes should be a string or null\");\r",
									"        pm.expect(item.classRecordingPath).to.satisfy(classRecordingPath => typeof classRecordingPath === \"string\" || classRecordingPath === null, \"classRecordingPath should be a string or null\");\r",
									"\r",
									"        pm.expect(item.batchName).to.satisfy(batchName => typeof batchName === \"string\" || batchName === null, \"batchName should be a string or null\");\r",
									"\r",
									"        // Correct the validation for classScheduledDates to be an array or null\r",
									"        pm.expect(item.classScheduledDates).to.satisfy(classScheduledDates => Array.isArray(classScheduledDates) || classScheduledDates === null, \"classScheduledDates should be an array or null\");\r",
									"    });\r",
									"});\r",
									"\r",
									"\r",
									"   const schema = {\r",
									"    \"type\": \"array\",\r",
									"    \"items\": {\r",
									"        \"type\": \"object\",\r",
									"        \"properties\": {\r",
									"            \"csId\": { \"type\": \"integer\" },\r",
									"            \"batchId\": { \"type\": \"integer\" },\r",
									"            \"classNo\": { \"type\": \"integer\" },\r",
									"            \"classDate\": { \"type\": \"string\", \"format\": \"date-time\" },\r",
									"            \"classTopic\": { \"type\": \"string\" },\r",
									"            \"classStatus\": { \"type\": [\"string\", \"null\"] },\r",
									"            \"classStaffId\": { \"type\": \"string\" },\r",
									"             \"classDescription\": { \"type\": [\"string\", \"null\"] },  \r",
									"            \"classComments\": { \"type\": [\"string\", \"null\"] }, \r",
									"            \"classNotes\": { \"type\": [\"string\", \"null\"] },  // Allows null if missing\r",
									"            \"classRecordingPath\": { \"type\": [\"string\", \"null\"] },\r",
									"            \"batchName\": { \"type\": \"string\" },\r",
									"            \"classScheduledDates\": {\r",
									"                \"type\": [\"array\", \"null\"],\r",
									"                \"items\": { \"type\": \"string\", \"format\": \"date-time\" }\r",
									"            }\r",
									"        },\r",
									"        \"required\": [\r",
									"            \"csId\",\r",
									"            \"batchId\",\r",
									"            \"classNo\",\r",
									"            \"classDate\",\r",
									"            \"classTopic\",\r",
									"            \"classStatus\",\r",
									"            \"classStaffId\",\r",
									"            \"classDescription\",\r",
									"            \"classComments\",\r",
									"            \"batchName\"\r",
									"        ]\r",
									"    }\r",
									"};\r",
									"\r",
									"// Validate the response\r",
									"pm.test(\"Response schema is valid\", function () {\r",
									"    pm.response.to.have.jsonSchema(schema);\r",
									"});\r",
									"\r",
									"}\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/classesByStaff/{{classStaffId}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"classesByStaff",
								"{{classStaffId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "GetAllClassesByStaffIdNoAuth",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"\r",
									"    pm.test(\"Should return 401 for unauthorized request\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(401);\r",
									"    });\r",
									"     pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Unauthorized\");\r",
									"    });\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/classesByStaff/{{classStaffId}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"classesByStaff",
								"{{classStaffId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "GetAllClassesByStaffIdInvalidEndpoint",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody=pm.response.json();\r",
									"\r",
									"pm.test(\"Should return 404 for not found\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(404);\r",
									"    });\r",
									" \r",
									" pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Not Found\");\r",
									"    });\r",
									"\r",
									"\r",
									" pm.test(\"Error message Invalid Endpoint\", function () {\r",
									"    pm.expect(responseBody.message).to.include(\"classes with this staffId staff not found\"); \r",
									"});\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/classesByStaff/staff",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"classesByStaff",
								"staff"
							]
						}
					},
					"response": []
				},
				{
					"name": "GetAllClassesByBatchIdNoAuth",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"\r",
									"    pm.test(\"Should return 401 for unauthorized request\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(401);\r",
									"    });\r",
									"     pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Unauthorized\");\r",
									"    });\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/batchRecordings/{{ValidBatchIdClass}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"batchRecordings",
								"{{ValidBatchIdClass}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "GetAllClassesValidBatchId",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Should return 200 for valid request\", function () {\r",
									"    pm.expect(pm.response.code).to.eql(200);\r",
									"});\r",
									"pm.test(\"Status code name has string\", function () {\r",
									"    pm.response.to.have.status(\"OK\");\r",
									"});\r",
									"\r",
									"//header validation\r",
									"pm.test(\"Header validation\", () => {\r",
									"    pm.response.to.have.header(\"Content-Type\");\r",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');\r",
									"});\r",
									"\r",
									"pm.test(\"validate response body properties\", () => {\r",
									"    // Check the expected properties exist\r",
									"    pm.expect(pm.response.text()).to.include(\"csId\");\r",
									"    pm.expect(pm.response.text()).to.include(\"classRecordingPath\");\r",
									"});\r",
									"\r",
									"pm.collectionVariables.set('ValidClassId', response[0].csId);\r",
									"\r",
									"pm.test(\"validate response body datatypes\", () => {\r",
									"    pm.expect(response).to.be.an(\"array\"); \r",
									"     response.forEach((item) => {\r",
									"    pm.expect(item.csId).to.be.a('number').and.to.not.be.null;\r",
									"    pm.expect(item.classRecordingPath).to.satisfy(classRecordingPath => typeof classRecordingPath === \"string\" || classRecordingPath === null, \"classRecordingPath should be a string or null\");\r",
									"     });\r",
									"});\r",
									"\r",
									"var responseSchema = {\r",
									"    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\r",
									"    \"type\": \"array\", \r",
									"    \"items\": {\r",
									"        \"type\": \"object\",\r",
									"        \"properties\": {\r",
									"            \"csId\": {\r",
									"                \"type\": \"number\"\r",
									"            },\r",
									"            \"classRecordingPath\": {\r",
									"                \"type\": [\"string\",\"null\"]\r",
									"            }\r",
									"        },\r",
									"        \"required\": [\r",
									"            \"csId\",\r",
									"            \"classRecordingPath\"\r",
									"        ]\r",
									"    }\r",
									"};\r",
									"pm.test(\"Validate schema\", () => {\r",
									"    pm.response.to.have.jsonSchema(responseSchema);\r",
									"});\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/batchRecordings/{{ValidBatchIdClass}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"batchRecordings",
								"{{ValidBatchIdClass}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "GetAllClassesInvalidBatchId",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"\r",
									"var response=pm.response.json();\r",
									"    pm.test(\"Should return 404 for Record Not Found\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(404);\r",
									"    });\r",
									"     pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Not Found\");\r",
									"    });\r",
									"//header validation\r",
									"pm.test(\"Header validation\", () => {\r",
									"    pm.response.to.have.header(\"Content-Type\");\r",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');\r",
									"    });\r",
									"\r",
									"    pm.test(\"Error message success false\", function () {\r",
									"   pm.expect(response.success).to.eql(false);\r",
									"});\r",
									"pm.test(\"Response contains invalid class id\", function () {\r",
									"\r",
									"    const responseText = pm.response.text();\r",
									"    const invalidClass = pm.collectionVariables.get(\"InvalidBatchIdClass\"); \r",
									"pm.expect(responseText).to.include(`Class Recording not found with batchId :${invalidClass}`);\r",
									"    \r",
									"});\r",
									"\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/batchRecordings/{{InvalidBatchIdClass}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"batchRecordings",
								"{{InvalidBatchIdClass}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "GetClassValidClassId",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var response = pm.response.json();\r",
									"\r",
									"pm.test(\"Should return 200 for unauthorized request\", function () {\r",
									"    pm.expect(pm.response.code).to.eql(200);\r",
									"});\r",
									"\r",
									"pm.test(\"Status code name has string\", function () {\r",
									"    pm.response.to.have.status(\"OK\");\r",
									"});\r",
									"\r",
									"//header validation\r",
									"pm.test(\"Header validation\", () => {\r",
									"    pm.response.to.have.header(\"Content-Type\");\r",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');\r",
									"});\r",
									"\r",
									"if (pm.response.code === 200) {\r",
									"    pm.test(\"validate response body properties\", () => {\r",
									"        // Check the expected properties exist\r",
									"        pm.expect(response).to.have.property(\"csId\");\r",
									"        pm.expect(response).to.have.property(\"batchId\");\r",
									"        pm.expect(response).to.have.property(\"classNo\");\r",
									"        pm.expect(response).to.have.property(\"classDate\");\r",
									"        pm.expect(response).to.have.property(\"classTopic\");\r",
									"        pm.expect(response).to.have.property(\"classStatus\");\r",
									"        pm.expect(response).to.have.property(\"classStaffId\");\r",
									"        pm.expect(response).to.have.property(\"classDescription\");\r",
									"        pm.expect(response).to.have.property(\"classComments\");\r",
									"        pm.expect(response).to.have.property(\"classNotes\");\r",
									"        pm.expect(response).to.have.property(\"classRecordingPath\");\r",
									"        pm.expect(response).to.have.property(\"batchName\");\r",
									"        pm.expect(response).to.have.property(\"classScheduledDates\");\r",
									"    });\r",
									"\r",
									"    pm.test(\"validate response body datatypes\", () => {\r",
									"        pm.expect(response).to.be.an(\"object\");\r",
									"        pm.expect(response.csId).to.be.a(\"number\").and.to.not.be.null;\r",
									"        pm.expect(response.batchId).to.be.a(\"number\").and.to.not.be.null;\r",
									"        pm.expect(response.classNo).to.be.a(\"number\").and.to.not.be.null;\r",
									"        pm.expect(response.classDate).to.be.a(\"string\").and.to.not.be.null;\r",
									"        pm.expect(response.classTopic).to.be.a(\"string\").and.to.not.be.null;\r",
									"        pm.expect(response.classStatus).to.be.a(\"string\").and.to.not.be.null;\r",
									"        pm.expect(response.classStaffId).to.be.a(\"string\").and.to.not.be.null;\r",
									"        pm.expect(response.classDescription).to.satisfy(classDescription => typeof classDescription === \"string\" || classDescription === null, \"classDescription should be a string or null\");\r",
									"        pm.expect(response.classComments).to.satisfy(classComments => typeof classComments === \"string\" || classComments === null, \"classComments should be a string or null\");\r",
									"        pm.expect(response.classNotes).to.satisfy(classNotes => typeof classNotes === \"string\" || classNotes === null, \"classNotes should be a string or null\");\r",
									"        pm.expect(response.classRecordingPath).to.satisfy(classRecordingPath => typeof classRecordingPath === \"string\" || classRecordingPath === null, \"classRecordingPath should be a string or null\");\r",
									"        pm.expect(response.batchName).to.satisfy(batchName => typeof batchName === \"string\" || batchName === null, \"batchName should be a string or null\");\r",
									"        pm.expect(response.classScheduledDates).to.satisfy(classScheduledDates => Array.isArray(classScheduledDates) || classScheduledDates === null, \"classScheduledDates should be an array or null\");\r",
									"    });\r",
									"\r",
									"    var responseSchema = {\r",
									"        \"type\": \"object\",\r",
									"        \"properties\": {\r",
									"            \"csId\": { \"type\": \"number\" },\r",
									"            \"batchId\": { \"type\": \"number\" },\r",
									"            \"classNo\": { \"type\": \"number\" },\r",
									"            \"classDate\": { \"type\": \"string\" },\r",
									"            \"classTopic\": { \"type\": \"string\" },\r",
									"            \"classStatus\": { \"type\": \"string\" },\r",
									"            \"classStaffId\": { \"type\": \"string\" },\r",
									"            \"classDescription\": { \"type\": [\"string\", \"null\"] },\r",
									"            \"classComments\": { \"type\": [\"string\", \"null\"] },\r",
									"            \"classNotes\": { \"type\": [\"string\", \"null\"] },\r",
									"            \"classRecordingPath\": { \"type\": [\"string\", \"null\"] },\r",
									"            \"batchName\": { \"type\": [\"string\", \"null\"] },\r",
									"            \"classScheduledDates\": {\r",
									"                \"type\": [\"array\", \"null\"],\r",
									"                \"items\": { \"type\": [\"string\", \"null\"] }\r",
									"            }\r",
									"        },\r",
									"        \"required\": [\r",
									"            \"csId\",\r",
									"            \"batchId\",\r",
									"            \"classNo\",\r",
									"            \"classDate\",\r",
									"            \"classTopic\",\r",
									"            \"classStatus\",\r",
									"            \"classStaffId\"\r",
									"        ]\r",
									"    };\r",
									"    pm.test(\"Validate schema\", () => {\r",
									"        pm.response.to.have.jsonSchema(responseSchema);\r",
									"    });\r",
									"}\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/class/{{ValidClassId}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"class",
								"{{ValidClassId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "GetClassInvalidClassId",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"\r",
									"var response=pm.response.json();\r",
									"    pm.test(\"Should return 404 for Record Not Found\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(404);\r",
									"    });\r",
									"     pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Not Found\");\r",
									"    });\r",
									"//header validation\r",
									"pm.test(\"Header validation\", () => {\r",
									"    pm.response.to.have.header(\"Content-Type\");\r",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');\r",
									"    });\r",
									"\r",
									"    pm.test(\"Error message success false\", function () {\r",
									"   pm.expect(response.success).to.eql(false);\r",
									"});\r",
									"pm.test(\"Response contains invalid class id\", function () {\r",
									"\r",
									"    const responseText = pm.response.text();\r",
									"    const invalidClass = pm.collectionVariables.get(\"InvalidClassId\"); \r",
									"pm.expect(responseText).to.include(`ClassSchedule is not found for classId :${invalidClass}`);\r",
									"    \r",
									"});\r",
									"\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/class/{{InvalidClassId}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"class",
								"{{InvalidClassId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "GetClassValidClassIdNoAuth",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"    pm.test(\"Should return 401 for unauthorized request\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(401);\r",
									"    });\r",
									"     pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Unauthorized\");\r",
									"    });"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/class/{{ValidClassId}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"class",
								"{{ValidClassId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "GetClassByClassIdInvalidEndPoint",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.text();\r",
									"\r",
									"pm.test(\"Should return 404 for not found\", function () {\r",
									"    pm.expect(pm.response.code).to.eql(404);\r",
									"});\r",
									"\r",
									"pm.test(\"Status code name has string\", function () {\r",
									"    pm.response.to.have.status(\"Not Found\");\r",
									"});\r",
									"\r",
									"pm.test(\"Error message Invalid Endpoint\", function () {\r",
									"    pm.expect(responseBody).to.include(\"Invalid endpoint\");\r",
									"});\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/class",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"class"
							]
						}
					},
					"response": []
				},
				{
					"name": "GetClassRecordingsValidClassIdNoAuth",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"    pm.test(\"Should return 401 for unauthorized request\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(401);\r",
									"    });\r",
									"     pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Unauthorized\");\r",
									"    });"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/classRecordings/{{ValidClassIdRecordings}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"classRecordings",
								"{{ValidClassIdRecordings}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "GetClassRecordingsInvalidEndPoint",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.text();\r",
									"\r",
									"pm.test(\"Should return 404 for not found\", function () {\r",
									"    pm.expect(pm.response.code).to.eql(404);\r",
									"});\r",
									"\r",
									"pm.test(\"Status code name has string\", function () {\r",
									"    pm.response.to.have.status(\"Not Found\");\r",
									"});\r",
									"\r",
									"pm.test(\"Error message Invalid Endpoint\", function () {\r",
									"    pm.expect(responseBody).to.include(\"Invalid endpoint\");\r",
									"});\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/classRecordings",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"classRecordings"
							]
						}
					},
					"response": []
				},
				{
					"name": "GetRecordingsDownloadNoAuth",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"    pm.test(\"Should return 401 for unauthorized request\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(401);\r",
									"    });\r",
									"     pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Unauthorized\");\r",
									"    });"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/download/{{ValidClassIdRecordings}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"download",
								"{{ValidClassIdRecordings}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "GetRecordingsDownloadInvalidEndpoint",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var responseBody = pm.response.text();\r",
									"\r",
									"pm.test(\"Should return 404 for not found\", function () {\r",
									"    pm.expect(pm.response.code).to.eql(404);\r",
									"});\r",
									"\r",
									"pm.test(\"Status code name has string\", function () {\r",
									"    pm.response.to.have.status(\"Not Found\");\r",
									"});\r",
									"\r",
									"pm.test(\"Error message Invalid Endpoint\", function () {\r",
									"    pm.expect(responseBody).to.include(\"Invalid endpoint\");\r",
									"});\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/download",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"download"
							]
						}
					},
					"response": []
				},
				{
					"name": "New Request",
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n    \"batchId\": 8455,\r\n    \"classNo\": 2,\r\n    \"classDate\": \"2024-11-23\",\r\n    \"classTopic\": \"Math 101\",\r\n    \"classStaffId\": \"U49\",\r\n    \"classDescription\": \"Introduction to Math\",\r\n    \"classComments\": \"None\",\r\n    \"classNotes\": \"None\",\r\n    \"classRecordingPath\": \"/recordings/math101\",\r\n    \"batchName\": \"Java Batch 01\",\r\n    \"classScheduledDates\": [\r\n        \"2024-15-11T15:11:08.750Z\",\r\n        \"2024-16-11T15:11:08.750Z\"\r\n    ]\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseurl}}/updateClass/677",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"updateClass",
								"677"
							]
						}
					},
					"response": []
				}
			],
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"packages": {},
						"exec": [
							"/*const module = pm.iterationData.get('module')?.trim();\r",
							"\r",
							"if (module?.toLowerCase() == 'program') {\r",
							"     pm.execution.skipRequest();       \r",
							"}*/"
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"packages": {},
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "DataCleanup",
			"item": [
				{
					"name": "DeleteClassValidClassId",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"var response = pm.response.json();\r",
									"\r",
									"pm.test(\"Should return 200 for unauthorized request\", function () {\r",
									"    pm.expect(pm.response.code).to.eql(200);\r",
									"});\r",
									"\r",
									"pm.test(\"Status code name has string\", function () {\r",
									"    pm.response.to.have.status(\"OK\");\r",
									"});\r",
									"\r",
									"//header validation\r",
									"pm.test(\"Header validation\", () => {\r",
									"    pm.response.to.have.header(\"Content-Type\");\r",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');\r",
									"});\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/deleteByClass/{{csId}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"deleteByClass",
								"{{csId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "BatchWithValidBatchId",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Should return 200 for valid request\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(200);\r",
									"    });\r",
									"     pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"OK\");\r",
									"    });\r",
									"\r",
									"\r",
									"pm.test(\"Response contains success message for batch deletion\", function () {\r",
									"    const responseText = pm.response.text();\r",
									"    const expectedBatchId = pm.collectionVariables.get(\"batchId_6\"); \r",
									"\r",
									"    pm.expect(responseText).to.include(`Batch with Id-${expectedBatchId} deleted Successfully`);\r",
									"});\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "{{baseurl}}/batches/{{batchId_23}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"batches",
								"{{batchId_23}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "BatchWithDeletedBatchId",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"\r",
									"   const response=pm.response.json();\r",
									"    pm.test(\"Should return 200 for valid request\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(200);\r",
									"    });\r",
									"     pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"OK\");\r",
									"    });\r",
									"\r",
									"    //header validation\r",
									"pm.test(\"Header validation\", () => {\r",
									"    pm.response.to.have.header(\"Content-Type\");\r",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');\r",
									"});\r",
									"\r",
									"if (pm.response.code === 200) {\r",
									"    pm.test(\"validate response body properties\", () => {\r",
									"        // Check the expected properties exist\r",
									"        pm.expect(pm.response.text()).to.include(\"batchId\");\r",
									"        pm.expect(pm.response.text()).to.include(\"batchName\");\r",
									"        pm.expect(pm.response.text()).to.include(\"batchDescription\");\r",
									"        pm.expect(pm.response.text()).to.include(\"batchStatus\");\r",
									"        pm.expect(pm.response.text()).to.include(\"batchNoOfClasses\");\r",
									"        pm.expect(pm.response.text()).to.include(\"programId\");\r",
									"        pm.expect(pm.response.text()).to.include(\"programName\");\r",
									"    });\r",
									"\r",
									"    pm.test(\"validate response body datatypes\", () => {\r",
									"        pm.expect(response.batchId).to.be.a(\"number\");\r",
									"        pm.expect(Number.isInteger(response.batchId)).to.be.true;\r",
									"        pm.expect(response.batchName).to.be.a(\"string\", \"batchName should be a string\").and.to.not.be.null;\r",
									"          pm.expect(response.batchDescription).to.satisfy(desc => typeof desc === \"string\" || desc === null, \"batchDescription should be a string or null\");\r",
									"        pm.expect(response.batchStatus).to.be.a(\"string\")\r",
									"        pm.expect(response.batchNoOfClasses).to.be.a(\"number\");\r",
									"        pm.expect(Number.isInteger(response.batchNoOfClasses)).to.be.true;\r",
									"        pm.expect(response.programId).to.be.a(\"number\");\r",
									"        pm.expect(Number.isInteger(response.programId)).to.be.true;\r",
									"\r",
									"        pm.expect(response.programName).to.be.a(\"string\", \"programName should be a string\").and.to.not.be.null;\r",
									"});\r",
									"\r",
									"// Schema validation\r",
									"const schema = {\r",
									"    \"type\": \"object\",\r",
									"    \"properties\": {\r",
									"        \"batchId\": { \"type\": \"integer\" },\r",
									"        \"batchName\": { \"type\": \"string\" },\r",
									"        \"batchDescription\": { \"type\": \"string\" },\r",
									"        \"batchStatus\": { \r",
									"            \"type\": \"string\",\r",
									"            \"enum\": [\"Active\", \"Inactive\"]  // Only allow these specific values\r",
									"        },\r",
									"        \"batchNoOfClasses\": { \"type\": \"integer\" },\r",
									"        \"programId\": { \"type\": \"integer\" },\r",
									"        \"programName\": { \"type\": \"string\" }\r",
									"    },\r",
									"    \"required\": [\"batchId\", \"batchName\", \"batchDescription\", \"batchStatus\", \"batchNoOfClasses\", \"programId\", \"programName\"]\r",
									"};\r",
									"\r",
									"// Validate the response body against the schema\r",
									"pm.test(\"Response matches the expected schema\", function () {\r",
									"    pm.response.to.have.jsonSchema(schema);\r",
									"});\r",
									"\r",
									"pm.test(\"Response matches to check inactive batch status\", function () {\r",
									"   pm.expect(response.batchStatus).to.eql(\"Inactive\");\r",
									"});\r",
									"\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{baseurl}}/batches/batchId/{{batchId_23}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"batches",
								"batchId",
								"{{batchId_23}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "BatchdeleteusingsecondbatchId",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Should return 200 for valid request\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(200);\r",
									"    });\r",
									"     pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"OK\");\r",
									"    });\r",
									"\r",
									"\r",
									"pm.test(\"Response contains success message for batch deletion\", function () {\r",
									"    const responseText = pm.response.text();\r",
									"    const expectedBatchId = pm.collectionVariables.get(\"batchId_7\"); \r",
									"\r",
									"    pm.expect(responseText).to.include(`Batch with Id-${expectedBatchId} deleted Successfully`);\r",
									"});\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "DELETE",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{baseurl}}/batches/{{batchId_24}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"batches",
								"{{batchId_24}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "BatchRetrieveWithDeletedBatch",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"\r",
									"   const response=pm.response.json();\r",
									"    pm.test(\"Should return 200 for valid request\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(200);\r",
									"    });\r",
									"     pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"OK\");\r",
									"    });\r",
									"\r",
									"    //header validation\r",
									"pm.test(\"Header validation\", () => {\r",
									"    pm.response.to.have.header(\"Content-Type\");\r",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');\r",
									"});\r",
									"\r",
									"if (pm.response.code === 200) {\r",
									"    pm.test(\"validate response body properties\", () => {\r",
									"        // Check the expected properties exist\r",
									"        pm.expect(pm.response.text()).to.include(\"batchId\");\r",
									"        pm.expect(pm.response.text()).to.include(\"batchName\");\r",
									"        pm.expect(pm.response.text()).to.include(\"batchDescription\");\r",
									"        pm.expect(pm.response.text()).to.include(\"batchStatus\");\r",
									"        pm.expect(pm.response.text()).to.include(\"batchNoOfClasses\");\r",
									"        pm.expect(pm.response.text()).to.include(\"programId\");\r",
									"        pm.expect(pm.response.text()).to.include(\"programName\");\r",
									"    });\r",
									"\r",
									"    pm.test(\"validate response body datatypes\", () => {\r",
									"        pm.expect(response.batchId).to.be.a(\"number\");\r",
									"        pm.expect(Number.isInteger(response.batchId)).to.be.true;\r",
									"        pm.expect(response.batchName).to.be.a(\"string\", \"batchName should be a string\").and.to.not.be.null;\r",
									"          pm.expect(response.batchDescription).to.satisfy(desc => typeof desc === \"string\" || desc === null, \"batchDescription should be a string or null\");\r",
									"        pm.expect(response.batchStatus).to.be.a(\"string\")\r",
									"        pm.expect(response.batchNoOfClasses).to.be.a(\"number\");\r",
									"        pm.expect(Number.isInteger(response.batchNoOfClasses)).to.be.true;\r",
									"        pm.expect(response.programId).to.be.a(\"number\");\r",
									"        pm.expect(Number.isInteger(response.programId)).to.be.true;\r",
									"\r",
									"        pm.expect(response.programName).to.be.a(\"string\", \"programName should be a string\").and.to.not.be.null;\r",
									"});\r",
									"\r",
									"// Schema validation\r",
									"const schema = {\r",
									"    \"type\": \"object\",\r",
									"    \"properties\": {\r",
									"        \"batchId\": { \"type\": \"integer\" },\r",
									"        \"batchName\": { \"type\": \"string\" },\r",
									"        \"batchDescription\": { \"type\": \"string\" },\r",
									"        \"batchStatus\": { \r",
									"            \"type\": \"string\",\r",
									"            \"enum\": [\"Active\", \"Inactive\"]  // Only allow these specific values\r",
									"        },\r",
									"        \"batchNoOfClasses\": { \"type\": \"integer\" },\r",
									"        \"programId\": { \"type\": \"integer\" },\r",
									"        \"programName\": { \"type\": \"string\" }\r",
									"    },\r",
									"    \"required\": [\"batchId\", \"batchName\", \"batchDescription\", \"batchStatus\", \"batchNoOfClasses\", \"programId\", \"programName\"]\r",
									"};\r",
									"\r",
									"// Validate the response body against the schema\r",
									"pm.test(\"Response matches the expected schema\", function () {\r",
									"    pm.response.to.have.jsonSchema(schema);\r",
									"});\r",
									"\r",
									"pm.test(\"Response matches to check inactive batch status\", function () {\r",
									"   pm.expect(response.batchStatus).to.eql(\"Inactive\");\r",
									"});\r",
									"\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{baseurl}}/batches/batchId/{{batchId_24}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"batches",
								"batchId",
								"{{batchId_24}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "ProgramdeleteusingProgramId",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Should return 200 for valid request\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(200);\r",
									"    });\r",
									"     pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"OK\");\r",
									"    });\r",
									"\r",
									"\r",
									"pm.test(\"Response contains success message for batch deletion\", function () {\r",
									"    const responseText = pm.response.text();\r",
									"    const expectedProgramId = pm.collectionVariables.get(\"programId\"); \r",
									"\r",
									"    pm.expect(responseText).to.include(`Program Id-${expectedProgramId} is deleted Successfully!`);\r",
									"});\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "DELETE",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{baseurl}}/deletebyprogid/{{ProgramId}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"deletebyprogid",
								"{{ProgramId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "BatchRetrieveAfterDeletingProgramId",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Should return 404 for not found\", function () {\r",
									"        pm.expect(pm.response.code).to.eql(404);\r",
									"    });\r",
									" \r",
									" pm.test(\"Status code name has string\", function () {\r",
									"        pm.response.to.have.status(\"Not Found\");\r",
									"    });\r",
									"pm.test(\"Response contains success message for batch deletion\", function () {\r",
									"    const responseText = pm.response.text();\r",
									"    const expectedProgId = pm.collectionVariables.get(\"programId\"); \r",
									"\r",
									"    pm.expect(responseText).to.include(`Batch not found with Id : ${expectedProgId} `);\r",
									"});\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{baseurl}}/batches/batchId/{{ProgramId}}",
							"host": [
								"{{baseurl}}"
							],
							"path": [
								"batches",
								"batchId",
								"{{ProgramId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "DELETE a Program using Program Name",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"var progName = pm.iterationData.get(\"programName\");\r",
									"\r",
									"var endpoint = pm.iterationData.get(\"EndPoint\");\r",
									"var baseUrl = pm.globals.get(\"baseurl\");\r",
									"\r",
									"// URL\r",
									"url = baseUrl + endpoint + '/' + progName;\r",
									"pm.environment.set(\"deletewithpnameurl\", url);\r",
									"\r",
									"console.log(\"URL :\"  + url);\r",
									"\r",
									"let auth_type = pm.iterationData.get(\"requiresAuth\");\r",
									"\r",
									"if (!auth_type) {\r",
									"   pm.request.auth = {\r",
									"    type: 'noauth'\r",
									"};\r",
									"}\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"const programResponseValidation = pm.require('@red-station-1386/program_response_validation');\r",
									"\r",
									"var statuscode = pm.iterationData.get('statuscode');\r",
									"programResponseValidation.validateStatusCode(statuscode);\r",
									"\r",
									"if (pm.response.code == 200) {\r",
									"    var response=pm.response.text();\r",
									"    programResponseValidation.deleteValidation(response, progId);\r",
									"}\r",
									"\r",
									"//need validation msgs for 4XX scenarios as well"
								],
								"type": "text/javascript",
								"packages": {
									"@red-station-1386/program_response_validation": {
										"id": "01931a2a-09f8-7749-8391-a62613bfc9cd"
									}
								}
							}
						}
					],
					"request": {
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "{{deletewithpnameurl}}",
							"host": [
								"{{deletewithpnameurl}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "DELETE a Program using Program Id",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"var progId = pm.collectionVariables.get('ProgramId');\r",
									"\r",
									"var endpoint = pm.iterationData.get(\"EndPoint\");\r",
									"var baseUrl = pm.globals.get(\"baseurl\");\r",
									"\r",
									"// URL\r",
									"url = baseUrl + endpoint + '/' + progId;\r",
									"pm.environment.set(\"deletewithpidurl\", url);\r",
									"\r",
									"console.log(\"URL :\"  + url);\r",
									"\r",
									"let auth_type = pm.iterationData.get(\"requiresAuth\");\r",
									"\r",
									"if (!auth_type) {\r",
									"   pm.request.auth = {\r",
									"    type: 'noauth'\r",
									"};\r",
									"}\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"const programResponseValidation = pm.require('@red-station-1386/program_response_validation');\r",
									"\r",
									"var statuscode = pm.iterationData.get('statuscode');\r",
									"var progId = pm.collectionVariables.get('ProgramId');\r",
									"\r",
									"programResponseValidation.validateStatusCode(statuscode);\r",
									"\r",
									"if (pm.response.code == 200) {\r",
									"    var response=pm.response.text();\r",
									"    programResponseValidation.deleteValidation(response, progId);\r",
									"}\r",
									"\r",
									"if (pm.response.code == 404) {\r",
									"    const jsonData = pm.response.json();\r",
									" \r",
									"    // Message: Program Id-10 is deleted Successfully!\r",
									"\r",
									"    pm.test(\"Delete already deleted program\", function () {\r",
									"        const expectedMessage = `no record found with programName`; //NEED TO BE SAME AS IN API DOCUMENT\r",
									"        pm.expect(jsonData.message).to.eql(expectedMessage);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Success field should be false\", function () {\r",
									"        pm.expect(jsonData.success).to.be.false;\r",
									"    });\r",
									"}\r",
									"\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {
									"@red-station-1386/program_response_validation": {
										"id": "01931a2a-09f8-7749-8391-a62613bfc9cd"
									}
								}
							}
						}
					],
					"request": {
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "{{deletewithpidurl}}",
							"host": [
								"{{deletewithpidurl}}"
							]
						}
					},
					"response": []
				}
			]
		}
	],
	"auth": {
		"type": "bearer",
		"bearer": [
			{
				"key": "token",
				"value": "{{access_token}}",
				"type": "string"
			}
		]
	},
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"exec": [
					""
				]
			}
		}
	],
	"variable": [
		{
			"key": "batchId",
			"value": ""
		},
		{
			"key": "batchName",
			"value": ""
		},
		{
			"key": "InactiveProgramId",
			"value": "",
			"type": "string"
		},
		{
			"key": "ActiveProgramId",
			"value": ""
		},
		{
			"key": "ActiveProgramName",
			"value": ""
		},
		{
			"key": "InactiveProgramName",
			"value": ""
		},
		{
			"key": "ProgramId",
			"value": ""
		},
		{
			"key": "ProgramName",
			"value": ""
		},
		{
			"key": "invalidLoginEndpoint",
			"value": "",
			"type": "string"
		},
		{
			"key": "InvalidClassId",
			"value": "",
			"type": "string"
		},
		{
			"key": "ValidClassId",
			"value": ""
		},
		{
			"key": "ValidClassIdRecordings",
			"value": ""
		},
		{
			"key": "InvalidClassIdRecordings",
			"value": ""
		},
		{
			"key": "ValidBatchIdClass",
			"value": ""
		},
		{
			"key": "csId",
			"value": "",
			"type": "string"
		},
		{
			"key": "classTopic",
			"value": "",
			"type": "string"
		},
		{
			"key": "classStaffId",
			"value": "",
			"type": "string"
		},
		{
			"key": "InvalidBatchIdClass",
			"value": "",
			"type": "string"
		},
		{
			"key": "ValidUserIdForGet",
			"value": ""
		},
		{
			"key": "ValidUserIdForDelete",
			"value": ""
		},
		{
			"key": "batchId_23",
			"value": ""
		},
		{
			"key": "batchName_23",
			"value": ""
		},
		{
			"key": "batchId_24",
			"value": ""
		},
		{
			"key": "batchName_24",
			"value": ""
		},
		{
			"key": "batchDescription",
			"value": "",
			"type": "string"
		},
		{
			"key": "invalidbatchId",
			"value": "",
			"type": "string"
		},
		{
			"key": "invalidBatchName",
			"value": "",
			"type": "string"
		},
		{
			"key": "invalidProgramId",
			"value": "",
			"type": "string"
		},
		{
			"key": "InvalidUserId",
			"value": "",
			"type": "string"
		}
	]
}